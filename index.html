<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tex To Canvas</title>
<script id="MathJax-script" async src="js/tex-svg-full.js"></script>
<script src="js/define.js"></script>
<script src="js/matrix.js"></script>
<script src="js/svg-parser.js"></script>
<script src="js/curve.js"></script>
<script src="js/utility.js"></script>
<script src="js/min-max.js"></script>
<script src="js/pixel.js"></script>
<script src="js/vector.js"></script>
<script src="js/seedrandom.min.js"></script>
<script src="js/app-svg.js"></script>
<script src="js/settings.js"></script>
<script>
const BLACK_BOARD_IMAGE_PATH = 'images/black_board.jpg';
const CHALK_IMAGE_PATH = 'images/hand3.png';

// Mathjaxの返すSVG => MVG
// KanjiVGのデータ => KVG
// アプリで定義されたSVG => AVG

let blackBoardImg = null;
let chalkImg = null;
let datas = [];
let animDatas = [];

// KanjiVGのファイル名から.svgを除いたコードの配列
let kvgCodes = null;

// アプリで定義した曲線群
let avgData = {};
let svgData = null;

let animIntervalId = -1;

document.addEventListener('DOMContentLoaded', async () => {

    attachEvents();

    Settings.load('tex2canvas-settings');
    Settings.createHtml('#settings-wrapper');
    Settings.attachEvents(load);

    // text
    const equation = localStorage.getItem('tex2canvas-equation');
    if(equation) {
        document.querySelector('#textarea').value = equation;
    }    

    try {
        const res = await fetch(Define.KVG_FILE);
        const data = await res.text();
        kvgCodes = data.split('\r\n').filter(d => d).map(d => d.replaceAll('.svg', ''));
    } catch(e) {

    }    

    avgData = AppSvg.load('tex2canvas');

    blackBoardImg = await Utility.loadImage(BLACK_BOARD_IMAGE_PATH);
    chalkImg = await Utility.loadImage(CHALK_IMAGE_PATH);

    //Settings.onChange();

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.reset();
    ctx.drawImage(blackBoardImg, 0, 0);
});
async function load() {
    datas = await loadDatas(); 
    //drawDatas(datas); 
    animDatas = getAnimDatas(datas);
    if(animIntervalId !== -1) {
        clearInterval(animIntervalId);
    }
    // 初期化
    let animCount = 0;
    let animCanvasArray = [];
    let animCtxArray = [];
    let animImageDataArray = [];
    let rectArray = [];
    animDatas.forEach(datas => {
        datas.forEach(data => {
            const animCanvas = Utility.createCanvas(data.rect.width, data.rect.height);
            const animCtx = animCanvas.getContext('2d');
            const animImageData = animCtx.getImageData(0, 0, animCtx.canvas.width, animCtx.canvas.height);
            
            animCanvasArray.push(animCanvas);
            animCtxArray.push(animCtx);    
            animImageDataArray.push(animImageData);       
            rectArray.push(data.rect);     
        });
    });
    let chalkPos = { x: 0, y: 0 };
    animIntervalId = setInterval(() => {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        ctx.reset();
        ctx.drawImage(blackBoardImg, 0, 0);
        // animCtxArrayを更新
        
        let elmCount = 0;
        let dataIndex = 0;
        let escapeFlag = false;
        for(let i = 0; i < animDatas.length; i += 1) {
            for(let j = 0; j < animDatas[i].length; j += 1) {
                for(let k = 0; k < animDatas[i][j].animArray.length; k += 1) {
                    const animData = animDatas[i][j];
                    const indexes = animData.animArray[k].indexes;
                    const imageData = animData.imageData;
                    if(animCount <= elmCount) {
                        const animImageData = animImageDataArray[dataIndex];
                        const data = animImageData.data;
                        indexes.forEach(l => {
                            data[l * 4 + 0] = imageData.data[l * 4 + 0];
                            data[l * 4 + 1] = imageData.data[l * 4 + 1];
                            data[l * 4 + 2] = imageData.data[l * 4 + 2];
                            data[l * 4 + 3] = imageData.data[l * 4 + 3];
                        });
                        animCtxArray[dataIndex].putImageData(animImageData, 0, 0);
                        chalkPos = animData.animArray[k].pos;
                        escapeFlag = true;
                    }
                    if(escapeFlag) { break; }
                    elmCount++;                    
                }
                if(escapeFlag) { break; }
                dataIndex += 1;
            }
            if(escapeFlag) { break; }
        }
        animCount++;

        for(let i = 0; i < animCanvasArray.length; i += 1) {
            const animCanvas = animCanvasArray[i];
            const rect = rectArray[i];
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, rect.x, rect.y);
            ctx.drawImage(animCanvas, 0, 0);
            ctx.restore();
        }
        // chalk 
        
        ctx.drawImage(chalkImg, chalkPos.x - 101, chalkPos.y - 26); // 101, 26
    }, 1000 / Settings.fps);
}
function getAnimDatas(datas) {
    const ret = [];
    datas.forEach(data => {
        if(data.type === 'app') {
            const strokeArray = [];
            data.curvesArray.forEach((curves, i) => {
                let posArray = [];
                curves.forEach((curve, j) => { 
                    let points = curve.divide();
                    const transMat = Matrix.translate(Settings.padding, Settings.padding);
                    const scaleMat = Matrix.scale(Settings.scale, Settings.scale);
                    let mat = Matrix.multiply(scaleMat, data.mat);
                    mat = Matrix.multiply(transMat, mat);
                    points = points.map(p => Matrix.multiplyVec(mat, p));
                    if(posArray.length === 0) {
                        posArray = posArray.concat(points);
                    } else {// 既に登録されている場合
                        // 前の最後の線分の終点と、今回の最初の線分の始点が一致する可能性がある
                        const last = posArray[posArray.length - 1];
                        const start = points[0];
                        const equal = Vector.equalsTo(last, start);
                        if(equal) {
                            points.shift();
                        } 
                        posArray = posArray.concat(points);
                    }
                });
                const pixelData = Pixel.getAnimationPixelData({
                    posArray: posArray, 
                    lineWidth: Settings.lineWidth, 
                    strokeStyle: { r: Settings.color.r, g: Settings.color.g, b: Settings.color.b, a: Settings.color.a }, 
                    boundaryThreshold: Settings.boundaryThreshold,   
                    internalThreshold: Settings.internalThreshold,
                    sigma: Settings.sigma, 
                    pps: Settings.pps,  
                    removeType: 'zero', // 'zero' or 'random'
                });
                strokeArray.push(pixelData);
            });
            ret.push(strokeArray);
        }
    });
    return ret;
}
function drawDatas(datas) {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    //ctx.reset();
    //ctx.drawImage(blackBoardImg, 0, 0);
    
    //datas.forEach(data => { drawData(ctx, data); });
}
function drawData(ctx, data) {
    const transMat = Matrix.translate(Settings.padding, Settings.padding);
    const scaleMat = Matrix.scale(Settings.scale, Settings.scale);
    let mat = Matrix.multiply(scaleMat, data.mat);
    mat = Matrix.multiply(transMat, mat);

    ctx.save();

    Matrix.setTransform(ctx, mat);

    ctx.strokeStyle = 'white';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = Settings.lineWidth / mat[0];
    if(data.type === 'app') {
        ctx.beginPath();
        data.curvesArray.forEach((curves, i) => {
            curves.forEach((curve, j) => { 
                curve.path(ctx, j === 0); 
            });
        });
        ctx.stroke();
    } else {
        data.kvg.paths.forEach(path => {                
            ctx.beginPath();
            path.curvesArray.forEach((curves, i) => {
                curves.forEach((curve, j) => { 
                    curve.path(ctx, j === 0); 
                });
            });
            ctx.stroke();
        });
    }

    ctx.restore();
}
async function loadDatas() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    // 設定内容の保存
    Settings.save('tex2canvas-settings');
    // 数式(MathJax用)
    const equation = document.querySelector('#textarea').value;
    localStorage.setItem('tex2canvas-equation', equation);
    const display = document.querySelector('#display-checkbox').checked;
    // svgに変換
    const svgText = SvgParser.getMathJaxSvgText(equation, display);
    // パースする
    svgData = SvgParser.parseMathJaxSvg(svgText);

    const kvgData = [];
    for(let i = 0; i < svgData.paths.length; i += 1) {
        const path = svgData.paths[i];
        let code = SvgParser.toKanjiVGCodeById(path.id);
        code = Utility.zeroPadding(code, 5);
        try {
            if(kvgCodes.indexOf(code) >= 0) {
                const ret = await SvgParser.loadSvg(code);
                kvgData.push(ret);
            } else {
                console.log(`${code} is not defined.`);
            }                
        } catch(e) {
            console.log(`${code} is error.`);
            throw 'error';
        }          
    }

    return getDatas(svgData, kvgData);
}
function drawSvg(ctx, svgData, options) {
    ctx.save();

    const transMat = Matrix.translate(Settings.padding, Settings.padding);
    const scaleMat = Matrix.scale(Settings.scale, Settings.scale);

    // ビューポート変換行列
    Matrix.setTransform(ctx, transMat);

    Matrix.transform(ctx, scaleMat);

    Matrix.transform(ctx, svgData.vpMat);

    svgData.shapes.forEach(shape => {
        ctx.save();
        // オブジェクト変換行列をかける
        Matrix.transform(ctx, shape.mat);

        // 描画するpathを取得する
        const path = svgData.paths.find(p => p.c === shape.c);
        if(!path) { return; } // continue;
        
        if(options.fillChar) {// 文字を塗る
            ctx.fillStyle = options.fillStyle ? options.fillStyle : 'green';
            ctx.lineWidth = 10;
            ctx.beginPath();
            path.curvesArray.forEach(curves => {
                curves.forEach((curve, i) => { 
                    curve.path(ctx, i === 0); 
                });
            });
            ctx.closePath();
            ctx.fill();
        }       
        
        if(options.strokeRect) {
            const rect = path.rect;
            ctx.strokeStyle = 'red';
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        }               

        ctx.restore();                 
    });

    ctx.restore();
}
function getDatas(svgData, kvgData) {
    const ret = [];

    // ret に kvgDataのインデックスと変換行列を格納していく
    svgData.shapes.forEach(shape => {
        if(shape.tagName === 'use') {// <use>
            // 描画するpathを取得する
            const path = svgData.paths.find(p => p.c === shape.c);
            if(!path) { return; } // continue;       

            // MathJax のshape.rectをスクリーン座標系へ変換する
            const mat = Matrix.multiply(svgData.vpMat, shape.mat);                
            const screenRect = Matrix.multiplyRect(mat, path.rect); // スクリーン座標系の矩形

            const id = shape.xlinkHref.substring(1);
            let kvgCode = SvgParser.toKanjiVGCodeById(id);
            kvgCode = Utility.zeroPadding(kvgCode, Define.SVG_FILE_NAME_LENGTH);
            let splits = id.split('-');
            const avgCode = splits[4]; 

            if(avgData[avgCode]) {
                // calc rect
                const curvesArray = avgData[avgCode].map(curves => {
                    return curves.map(elm => new Curve(elm.points));
                });
                const rect = getCurvesArrayRect(curvesArray);
                // push data
                ret.push({ type: 'app', curvesArray, mat: getNewMatrix(screenRect, rect), });
            } else {
                // get kvg paths
                const data = kvgData.find(data => data.c === kvgCode); 
                if(!data) { 
                    console.log('kvg paths are not found.');
                    return;
                }
                // push data
                ret.push({ type: 'kvg', kvg: data, mat: getNewMatrix(screenRect, data.rect), });
            }
        } else if(shape.tagName === 'rect') {
            // MathJax のshape.rectをスクリーン座標系へ変換する
            const mat = Matrix.multiply(svgData.vpMat, shape.mat);                
            const screenRect = Matrix.multiplyRect(mat, shape.rect); // スクリーン座標系の矩形
            const curvesArray = [
                [new Curve([{ x: 0, y: 0 }, { x: 30, y: 0 }, { x: 60, y: 0 }, { x: 90, y: 0 }]) ]
            ];
            const rect = getCurvesArrayRect(curvesArray);
                
            ret.push({ type: 'app', curvesArray, mat: getNewMatrix(screenRect, rect), });
        }                
    });

    return ret;
}
function attachEvents() {
    // ボタン押下時の処理
    document.querySelector('#button').addEventListener('click', async () => {
        Settings.onChange();
    });

    // テキストでCtrl + Sした時の処理
    document.querySelector('#textarea').addEventListener('keydown', async e => {
        if(e.ctrlKey && e.key === 's') {
            e.preventDefault(); // Prevent the Save dialog to open
            Settings.onChange();
        }
    });
}
function getCurvesArrayRect(curvesArray) {
    MinMax.save();
    MinMax.init();        
    curvesArray.forEach(curves => {
        curves.forEach(curve => {
            const rect = curve.rect();
            MinMax.add({ x: rect.x, y: rect.y, });
            MinMax.add({ x: rect.x + rect.width, y: rect.y + rect.height, });
        });
    });      
    const rect = MinMax.getRect();
    MinMax.restore();
    return rect;
}
function getNewMatrix(screenRect, rect) {
    let aspect;
    if(rect.height < 0.01) {
        aspect = 100;
    } else {
        aspect= rect.width / rect.height;
    }
    let newRect = Utility.fitVerticalRect(screenRect, rect);
    if(aspect > 5) {
        newRect = Utility.fitHorizontalRect(screenRect, rect);                        
    }

    // 変換行列を求める
    const trans = Matrix.translate(-newRect.x, -newRect.y);
    const scale = Matrix.scale(screenRect.width / newRect.width, screenRect.height / newRect.height);
    const revTrans = Matrix.translate(screenRect.x, screenRect.y);

    let newMat = Matrix.multiply(scale, trans);
    newMat = Matrix.multiply(revTrans, newMat);
    return newMat;
}
</script>
<style>
#textarea {
	width: 600px;
	height: 200px;
    font-size: 18px;
}
.mb-8 {
    margin-bottom: 8px;
}
</style>
</head>
<body>
    <div class="mb-8">
	    <textarea id="textarea"></textarea>
    </div>
    <div class="mb-8">
	    <input id="display-checkbox" type="checkbox" checked="true"/><label for="display-checkbox">display</label>    
        <button id="button">tex2svg</button>
        &nbsp;&nbsp;
        <a href="char-def.html">char-def</a>&nbsp;&nbsp;
        <a href="my-chalk.html">my-chalk</a>&nbsp;&nbsp;
        <a href="input-tex2svg.html">sample page</a>
    </div>
    <div id="settings-wrapper" class="mb-8">
    </div>
	<canvas id="canvas" width="1024" height="576"></canvas>
</body>
</html>
