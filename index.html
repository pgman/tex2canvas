<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tex To Canvas</title>
<script id="MathJax-script" async src="js/tex-svg-full.js"></script>
<script src="js/define.js"></script>
<script src="js/matrix.js"></script>
<script src="js/svg-parser.js"></script>
<script src="js/curve.js"></script>
<script src="js/utility.js"></script>
<script>
/*
[bug]
・"備"がエラーが出てしまう 
   -> プロパティ内に半角スペースがあるのが原因かな？
   -> 半角スペースを削除したがダメ
   -> m(小文字)の処理がうまくできていない感じがする
*/
// 参考URL
// https://stackoverflow.com/questions/71031646/write-svg-latex-into-a-canvas-html

/*
Mathjax demo
https://mathjax.github.io/MathJax-demos-web/input-tex2svg.html.html
display: boolean でインラインかどうかわ変えることができそう -> できた
ところで、$～$ や $$～$$は意味なさそう
*/

/**
 * 開発用TODO(時間かかりそう)
 * ・16進数コードから漢字に変換するプログラムを作成する(http://d.hatena.ne.jp/yasuhallabo/20140211/1392131668) -> うまくいっていない(保留)
 *   https://gist.github.com/seekseep/e5c289791265dafee786640942ee2e4d -> これでもうまくいかない -> 16進数コードから日本語の復元がうまくいかない
 *   -> Bufferが使えるのはNodeのみなので、おそらくArrayBufferを使う
 * ・primise error を調べる
 * ・初期の拡大率調査 => 現状hugeをつけないと文字サイズが小さい件を調査する => display以外効かないので、もうソフト的に拡大とマージンを設けた
 * 
 * 
 * 行列の()は縦に長くなると複数のパスになる。これはうまく対応したところではある <- 長括弧対応
 * サイズを指定せずに svg の幅と高さを変えた方がよいかもしれない
 * そうすると、\bar{x} によるバーとのずれが無くなると思う
 * 
 * デモで動作させたい数式
 * \大きめの行列
 * \大きな括弧に対応しないといけない
 */
// 日本語入力したときはpathが取れない？

// KanjiVGのファイル名から.svgを除いたコードの配列
let kvgCodes = null;

// アプリで定義した曲線群
let appFont = {};

let dispLineWidth = 5;
let dispScale = 2;
let dispPadding = 20;

const MIN_LINE_WIDTH = 1;
const MAX_LINE_WIDTH = 20;
const STEP_LINE_WIDTH = 1;

const MIN_SCALE = 1;
const MAX_SCALE = 5;
const STEP_SCALE = 0.5;

const MIN_PADDING = 0;
const MAX_PADDING = 50;
const STEP_PADDING = 5;

const STRING_COLOR = 'rgb(255, 255, 255)';
const BLACK_BOARD_IMAGE_PATH = 'images/black_board.jpg';

let blackBoardImg = null;
let datas = [];

document.addEventListener('DOMContentLoaded', async () => {

    attachEvents();

    // init select
    let html = '';
    for(let i = MIN_LINE_WIDTH; i <= MAX_LINE_WIDTH; i += STEP_LINE_WIDTH) {
        html += `<option value="${i}" ${i === dispLineWidth ? 'selected' : ''}>${i}px</option>`;
    }
    document.querySelector('#line-width-select').innerHTML = html;

    html = '';
    for(let i = MIN_SCALE; i <= MAX_SCALE; i += STEP_SCALE) {
        html += `<option value="${i}" ${i === dispScale ? 'selected' : ''}>x ${i}</option>`;
    }
    document.querySelector('#scale-select').innerHTML = html;

    html = '';
    for(let i = MIN_PADDING; i <= MAX_PADDING; i += STEP_PADDING) {
        html += `<option value="${i}" ${i === dispPadding ? 'selected' : ''}>${i}px</option>`;
    }
    document.querySelector('#padding-select').innerHTML = html;

    // select event handler
    document.querySelector('#line-width-select').addEventListener('change', onChange);
    document.querySelector('#scale-select').addEventListener('change', onChange);
    document.querySelector('#padding-select').addEventListener('change', onChange);

    // text
    const equation = localStorage.getItem('tex2canvas-input');
    if(equation) {
        document.querySelector('#textarea').value = equation;
    }

    try {
        const res = await fetch(Define.KVG_FILE);
        const data = await res.text();
        kvgCodes = data.split('\r\n').filter(d => d).map(d => d.replaceAll('.svg', ''));
    } catch(e) {

    }    

    const jsonStr = localStorage.getItem('tex2canvas');
    if(jsonStr) {
        appFont = JSON.parse(jsonStr);
    }

    blackBoardImg = await Utility.loadImage(BLACK_BOARD_IMAGE_PATH);

    datas = await loadDatas();
    drawDatas(datas);    
});

function drawDatas(datas) {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.drawImage(blackBoardImg, 0, 0);
    for(let i = 0; i < datas.length; i += 1) {
        drawData(ctx, datas[i]);
    }
}

function drawData(ctx, data) {
    const transMat = Matrix.translate(dispPadding, dispPadding);
    const scaleMat = Matrix.scale(dispScale, dispScale);
    let mat = Matrix.multiply(scaleMat, data.mat);
    mat = Matrix.multiply(transMat, mat);

    ctx.save();

    Matrix.setTransform(ctx, mat);

    ctx.strokeStyle = 'white';
    ctx.lineCap = 'round';
    ctx.lineWidth = dispLineWidth / mat[0];
    if(data.type === 'app') {
        ctx.beginPath();
        data.curvesArray.forEach((curves, i) => {
            curves.forEach((curve, j) => { 
                curve.path(ctx, j === 0); 
            });
        });
        ctx.stroke();
    } else {
        data.kvg.paths.forEach(path => {                
            ctx.beginPath();
            path.curvesArray.forEach((curves, i) => {
                curves.forEach((curve, j) => { 
                    curve.path(ctx, j === 0); 
                });
            });
            ctx.stroke();
        });
    }

    ctx.restore();
}

async function loadDatas() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    // 数式(MathJax用)
    const equation = document.querySelector('#textarea').value;
    localStorage.setItem('tex2canvas-input', equation);
    const display = document.querySelector('#display-checkbox').checked;
    // svgに変換
    const svgText = SvgParser.getMathJaxSvgText(equation, display);
    // パースする
    const svgData = SvgParser.parseMathJaxSvg(svgText);

    const kvgData = [];
    for(let i = 0; i < svgData.paths.length; i += 1) {
        const path = svgData.paths[i];
        let code = SvgParser.toKanjiVGCodeById(path.id);
        code = Utility.zeroPadding(code, 5);
        try {
            if(kvgCodes.indexOf(code) >= 0) {
                const ret = await SvgParser.loadSvg(code);
                kvgData.push(ret);
            } else {
                console.log(`${code} is not defined.`);
            }                
        } catch(e) {
            console.log(`${code} is error.`);
            throw 'error';
        }          
    }

    return getDatas(svgData, kvgData);
}
function drawSvg(ctx, svgData, options) {
    ctx.save();

    // ビューポート変換行列
    Matrix.setTransform(ctx, svgData.vpMat);

    svgData.shapes.forEach(shape => {
        ctx.save();
        // オブジェクト変換行列をかける
        Matrix.transform(ctx, shape.mat);

        // 描画するpathを取得する
        const path = svgData.paths.find(p => p.c === shape.c);
        if(!path) { return; } // continue;
        
        if(options.fillChar) {// 文字を塗る
            ctx.fillStyle = options.fillStyle ? options.fillStyle : 'green';
            ctx.lineWidth = 10;
            ctx.beginPath();
            path.curvesArray.forEach(curves => {
                curves.forEach((curve, i) => { 
                    curve.path(ctx, i === 0); 
                });
            });
            ctx.closePath();
            ctx.fill();
        }       
        
        if(options.strokeRect) {
            const rect = path.rect;
            ctx.strokeStyle = 'red';
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        }               

        ctx.restore();                 
    });

    ctx.restore();
}
function getDatas(svgData, kvgData) {
    const ret = [];

    // ret に kvgDataのインデックスと変換行列を格納していく
    svgData.shapes.forEach(shape => {
        if(shape.tagName === 'use') {// <use>
            // 描画するpathを取得する
            const path = svgData.paths.find(p => p.c === shape.c);
            if(!path) { return; } // continue;       

            // MathJax のshape.rectをスクリーン座標系へ変換する
            const mat = Matrix.multiply(svgData.vpMat, shape.mat);                
            const screenRect = Matrix.multiplyRect(mat, path.rect); // スクリーン座標系の矩形

            const id = shape.xlinkHref.substring(1);
            let kvgCode = SvgParser.toKanjiVGCodeById(id);
            kvgCode = Utility.zeroPadding(kvgCode, Define.SVG_FILE_NAME_LENGTH);
            let splits = id.split('-');
            const apfCode = splits[4]; 

            if(appFont[apfCode]) {
                // calc rect
                const curvesArray = appFont[apfCode].map(curves => {
                    return curves.map(elm => new Curve(elm.points));
                });
                const rect = getCurvesArrayRect(curvesArray);
                // push data
                ret.push({ type: 'app', curvesArray, mat: getNewMatrix(screenRect, rect), });
            } else {
                // get kvg paths
                const data = kvgData.find(data => data.c === kvgCode); 
                if(!data) { 
                    console.log('kvg paths are not found.');
                    return;
                }
                // push data
                ret.push({ type: 'kvg', kvg: data, mat: getNewMatrix(screenRect, data.rect), });
            }
        } else if(shape.tagName === 'rect') {
            // MathJax のshape.rectをスクリーン座標系へ変換する
            const mat = Matrix.multiply(svgData.vpMat, shape.mat);                
            const screenRect = Matrix.multiplyRect(mat, shape.rect); // スクリーン座標系の矩形
            const curvesArray = [
                [new Curve([{ x: 0, y: 0 }, { x: 30, y: 0 }, { x: 60, y: 0 }, { x: 90, y: 0 }]) ]
            ];
            const rect = getCurvesArrayRect(curvesArray);
                
            ret.push({ type: 'app', curvesArray, mat: getNewMatrix(screenRect, rect), });
        }                
    });

    return ret;
}

function attachEvents() {
    // ボタン押下時の処理
    document.querySelector('#button').addEventListener('click', async () => {
        datas = await loadDatas(); 
        drawDatas(datas); 
    });

    // テキストでCtrl + Sした時の処理
    document.querySelector('#textarea').addEventListener('keydown', async e => {
        if(e.ctrlKey && e.key === 's') {
            e.preventDefault(); // Prevent the Save dialog to open
            datas = await loadDatas();   
            drawDatas(datas); 
        }
    });
}

async function onChange() {
    dispLineWidth = Number(document.querySelector('#line-width-select').value);
    dispScale = Number(document.querySelector('#scale-select').value);
    dispPadding = Number(document.querySelector('#padding-select').value);
    datas = await loadDatas();   
    drawDatas(datas); 
}

function getCurvesArrayRect(curvesArray) {        
    let minX = Number.MAX_VALUE, minY = Number.MAX_VALUE,
        maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;

    curvesArray.forEach(curves => {
        curves.forEach(curve => {
            const rect = curve.rect();
            if(rect.x < minX) { minX = rect.x; }
            if(rect.y < minY) { minY = rect.y; }
            if(rect.x + rect.width > maxX) { maxX = rect.x + rect.width; }
            if(rect.y + rect.height > maxY) { maxY = rect.y + rect.height; }
        });
    });            
    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
}
function getNewMatrix(screenRect, rect) {
    let aspect;
    if(rect.height < 0.01) {
        aspect = 100;
    } else {
        aspect= rect.width / rect.height;
    }
    let newRect = Utility.fitVerticalRect(screenRect, rect);
    if(aspect > 5) {
        newRect = Utility.fitHorizontalRect(screenRect, rect);                        
    }

    // 変換行列を求める
    const trans = Matrix.translate(-newRect.x, -newRect.y);
    const scale = Matrix.scale(screenRect.width / newRect.width, screenRect.height / newRect.height);
    const revTrans = Matrix.translate(screenRect.x, screenRect.y);

    let newMat = Matrix.multiply(scale, trans);
    newMat = Matrix.multiply(revTrans, newMat);
    return newMat;
}
</script>
<style>
#textarea {
	width: 600px;
	height: 200px;
    font-size: 18px;
}
.mb-8 {
    margin-bottom: 8px;
}
</style>
</head>
<body>
    <div class="mb-8">
	    <textarea id="textarea"></textarea>
    </div>
    <div class="mb-8">
	    <input id="display-checkbox" type="checkbox" checked="true"/><label for="display-checkbox">display</label>    
        <button id="button">tex2svg</button>
        &nbsp;&nbsp;
        <a href="char-def.html">char-def</a>&nbsp;&nbsp;<a href="input-tex2svg.html">sample page</a>
    </div>
    <div class="mb-8">
        lineWidth:&nbsp;
        <select id="line-width-select"></select>&nbsp;&nbsp;
        scale:&nbsp;
        <select id="scale-select"></select>&nbsp;&nbsp;
        padding:&nbsp;
        <select id="padding-select"></select>&nbsp;&nbsp;
    </div>
	<canvas id="canvas" width="1024" height="576"></canvas>
</body>
</html>
