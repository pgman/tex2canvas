<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tex To Canvas</title>
<script>
// MathJax = {
//   tex: {
//     inlineMath: [
//       ['$', '$'],
//       ['\\(', '\\)']
//     ],
//     displayMath: [
//       ['$$', '$$'],
//       ['\\[', '\\]']
//     ],
//     processEscapes: true // use \$ to produce a literal dollar sign (true is default)
//   },
//   svg: {
//     scale: 1,                      // global scaling factor for all expressions
//     minScale: .5,                  // smallest scaling factor to use
//     //matchFontHeight: true,         // true to match ex-height of surrounding font
//     mtextInheritFont: false,       // true to make mtext elements use surrounding font
//     merrorInheritFont: true,       // true to make merror text use surrounding font
//     mathmlSpacing: false,          // true for MathML spacing rules, false for TeX rules
//     skipAttributes: {},            // RFDa and other attributes NOT to copy to the output
//     exFactor: .5,                  // default size of ex in em units
//     displayAlign: 'center',        // default for indentalign when set to 'auto'
//     displayIndent: '0',            // default for indentshift when set to 'auto'
//     fontCache: 'local',            // or 'global' or 'none'
//     localID: null,                 // ID to use for local font cache (for single equation processing)
//     internalSpeechTitles: true,    // insert <title> tags with speech content
//     titleID: 0                     // initial id number to use for aria-labeledby titles
//   },
// };
</script>
<script id="MathJax-script" async src="js/tex-svg-full.js"></script>
<script src="js/define.js"></script>
<script src="js/matrix.js"></script>
<script src="js/svg-parser.js"></script>
<script src="js/curve.js"></script>
<script src="js/utility.js"></script>
<script>
/*
[bug]
・"備"がエラーが出てしまう 
   -> プロパティ内に半角スペースがあるのが原因かな？
   -> 半角スペースを削除したがダメ
   -> m(小文字)の処理がうまくできていない感じがする
*/
// 参考URL
// https://stackoverflow.com/questions/71031646/write-svg-latex-into-a-canvas-html
// 課題
// インラインの表示がうまくいかない
// もうね \begin{eqnarray}日本語x^2\\x^3\end{eqnarray}でいいと思うんだ
// textareaに色付けたいかな -> ace.jsでいけそう

// TODO 
// ・日本語入力したときはpathが取れない？
// ・なので日本語入力には対応しないでいいんじゃないかな？

// TODO 図形のtexはいけるはず
// 以下がいけない。texclipではいける。うーん問題だね -> 多分mathjaxは対応していない
/*
\begin{picture}(40,40)(-20,-20)
  \put(-20,-20){\framebox(40,40){}}% 外見の領域全体を囲む枠
  \put(0,0){\circle*{4}}% 原点の位置
\end{picture}
*/

/*
Mathjax demo
https://mathjax.github.io/MathJax-demos-web/input-tex2svg.html.html
display: boolean でインラインかどうかわ変えることができそう -> できた
ところで、$～$ や $$～$$は意味なさそう
*/

/**
 * 開発用TODO
 * ・16進数コードから漢字に変換するプログラムを作成する(http://d.hatena.ne.jp/yasuhallabo/20140211/1392131668) -> うまくいっていない(保留)
 *   https://gist.github.com/seekseep/e5c289791265dafee786640942ee2e4d -> これでもうまくいかない -> 16進数コードから日本語の復元がうまくいかない
 *   -> Bufferが使えるのはNodeのみなので、おそらくArrayBufferを使う
 * ・KanjiVGのsvgを表示する
 * ・KanjiVGのsvgをMathJaxのSvgの位置に合わせる
 * rect 対応する
 * []について調べる
 * 行列の()は縦に長くなると複数のパスになる。これはうまく対応したところではある <- 長括弧対応
 * サイズを指定せずに svg の幅と高さを変えた方がよいかもしれない
 * そうすると、\bar{x} によるバーとのずれが無くなると思う
 * 
 * デモで動作させたい数式
 * \int \frac {\bf x}
 * アルファベット大文字、小文字, 
 * ギリシャ文字の大文字、小文字は定義する
 */

// <path> の id が - でいくつに区切られているか
const PATH_ID_SEPARATE_COUNT = 5;

document.addEventListener('DOMContentLoaded', async () => {

    attachEvents();

    function attachEvents() {
        // ボタン押下時の処理
        document.querySelector('#button').addEventListener('click', svg2canvas);

        // テキストでCtrl + Sした時の処理
        document.querySelector('#textarea').addEventListener('keydown', e => {
            if(e.ctrlKey && e.key === 's') {
                e.preventDefault(); // Prevent the Save dialog to open
                svg2canvas();   
            }
        });
    }

    async function svg2canvas() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        // 数式(MathJax用)
        const equation = document.querySelector('#textarea').value;
        const display = document.querySelector('#display-checkbox').checked;
        //console.log();
        // svgに変換
        const svgText = SvgParser.getMathJaxSvgText(equation, display);
        //const svgText = await SvgParser.getMathJaxSvgTextAsync(equation, display);
        // パースする
        const svgData = SvgParser.parseMathJaxSvg(svgText);

        const kanjiVGPathsArray = [];
        for(let i = 0; i < svgData.paths.length; i += 1) {
          const path = svgData.paths[i];
          let code = SvgParser.toKanjiVGCodeById(path.id);
          code = Utility.zeroPadding(code, 5);
          try {
            const paths = await SvgParser.loadSvg(code);
            kanjiVGPathsArray.push(paths);
          } catch(e) {
            console.log(`${code} is error.`);
          }          
        }
        
        const img = document.createElement('img');
        img.onload = (e) => {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.drawImage(e.target, 0, 0, e.target.naturalWidth, e.target.naturalHeight);
            drawSvg(svgData);  
            drawKanjiVG(kanjiVGPathsArray, svgData);
        }
        img.src = 'data:image/svg+xml;base64,' + btoa('<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n' + svgText);        

        // 
        function drawKanjiVG(kanjiVGPathsArray, svgData) {
          ctx.save();
          kanjiVGPathsArray.forEach((paths, i) => {
            //if(i === 0) {return;}
            ctx.strokeStyle = 'blue';
            ctx.fillStyle = 'blue';
            ctx.lineWidth = 2;
            paths.forEach(path => {
              ctx.beginPath();

              path.curvesArray.forEach(curves => {
                  curves.forEach((curve, j) => { 
                      curve.path(ctx); 
                  });
              });

              ctx.stroke();
            });

          });
          ctx.restore();
        }
        // svgDataに基づいて描画
        function drawSvg(svgData) {
            
            ctx.save();

            // ビューポート変換行列
            Matrix.setTransform(ctx, svgData.vpMat);

            svgData.geoms.forEach((geom, gi) => {
                ctx.save();
                // オブジェクト変換行列をかける
                Matrix.transform(ctx, geom.mat);

                // 描画するpathを取得する
                const path = svgData.paths.find(p => p.c === geom.c);
                if(!path) { return; } // continue;                

                // 描画する
                ctx.strokeStyle = 'green';
                ctx.fillStyle = 'green';
                ctx.lineWidth = 10;
                ctx.beginPath();

                path.curvesArray.forEach(curves => {
                    curves.forEach((curve, i) => { 
                        curve.path(ctx, i === 0); 
                    });
                });

                ctx.closePath();
                ctx.fill();

                const rect = path.rect;
                ctx.strokeStyle = 'red';
                ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);

                ctx.restore();
            });

            ctx.restore();
        }
    }
});
</script>
<style>
#textarea {
	width: 600px;
	height: 200px;
    font-size: 18px;
}
#canvas {
  border: 1px solid #eeeeee;
}
</style>
</head>
<body>
	<textarea id="textarea">\huge{\begin{eqnarray}
2
\end{eqnarray}}</textarea><br>
	<input id="display-checkbox" type="checkbox" checked="true"/><label for="display-checkbox">display</label>    
    <button id="button">tex2svg</button>
    &nbsp;&nbsp;
    <a href="input-tex2svg.html">sample page</a><br><br>
	<canvas id="canvas" width="600" height="300"></canvas>
</body>
</html>
