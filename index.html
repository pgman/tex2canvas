<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tex To Canvas</title>
<script id="MathJax-script" async src="js/tex-svg-full.js"></script>
<script src="js/define.js"></script>
<script src="js/matrix.js"></script>
<script src="js/svg-parser.js"></script>
<script src="js/curve.js"></script>
<script src="js/utility.js"></script>
<script>
/*
[bug]
・"備"がエラーが出てしまう 
   -> プロパティ内に半角スペースがあるのが原因かな？
   -> 半角スペースを削除したがダメ
   -> m(小文字)の処理がうまくできていない感じがする
*/
// 参考URL
// https://stackoverflow.com/questions/71031646/write-svg-latex-into-a-canvas-html
// 課題
// インラインの表示がうまくいかない
// もうね \begin{eqnarray}日本語x^2\\x^3\end{eqnarray}でいいと思うんだ
// textareaに色付けたいかな -> ace.jsでいけそう

// TODO 
// ・日本語入力したときはpathが取れない？
// ・なので日本語入力には対応しないでいいんじゃないかな？

// TODO 図形のtexはいけるはず
// 以下がいけない。texclipではいける。うーん問題だね -> 多分mathjaxは対応していない
/*
\begin{picture}(40,40)(-20,-20)
  \put(-20,-20){\framebox(40,40){}}% 外見の領域全体を囲む枠
  \put(0,0){\circle*{4}}% 原点の位置
\end{picture}
*/

/*
Mathjax demo
https://mathjax.github.io/MathJax-demos-web/input-tex2svg.html.html
display: boolean でインラインかどうかわ変えることができそう -> できた
ところで、$～$ や $$～$$は意味なさそう
*/

/**
 * 開発用TODO
 * ・16進数コードから漢字に変換するプログラムを作成する(http://d.hatena.ne.jp/yasuhallabo/20140211/1392131668) -> うまくいっていない(保留)
 *   https://gist.github.com/seekseep/e5c289791265dafee786640942ee2e4d -> これでもうまくいかない -> 16進数コードから日本語の復元がうまくいかない
 *   -> Bufferが使えるのはNodeのみなので、おそらくArrayBufferを使う
 * ・kvgを表示する
 * ・kvgをMathJaxのSvgの位置に合わせる
 * rect 対応する
 * []について調べる
 * 行列の()は縦に長くなると複数のパスになる。これはうまく対応したところではある <- 長括弧対応
 * サイズを指定せずに svg の幅と高さを変えた方がよいかもしれない
 * そうすると、\bar{x} によるバーとのずれが無くなると思う
 * 
 * デモで動作させたい数式
 * \int \frac {\bf x}
 * アルファベット大文字、小文字, 
 * ギリシャ文字の大文字、小文字は定義する
 */

// <path> の id が - でいくつに区切られているか
const PATH_ID_SEPARATE_COUNT = 5;

document.addEventListener('DOMContentLoaded', async () => {

    attachEvents();

    function attachEvents() {
        // ボタン押下時の処理
        document.querySelector('#button').addEventListener('click', svg2canvas);

        // テキストでCtrl + Sした時の処理
        document.querySelector('#textarea').addEventListener('keydown', e => {
            if(e.ctrlKey && e.key === 's') {
                e.preventDefault(); // Prevent the Save dialog to open
                svg2canvas();   
            }
        });
    }

    async function svg2canvas() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        // 数式(MathJax用)
        const equation = document.querySelector('#textarea').value;
        const display = document.querySelector('#display-checkbox').checked;
        // svgに変換
        const svgText = SvgParser.getMathJaxSvgText(equation, display);
        //const svgText = await SvgParser.getMathJaxSvgTextAsync(equation, display);
        // パースする
        const svgData = SvgParser.parseMathJaxSvg(svgText);

        const kvgData = [];
        for(let i = 0; i < svgData.paths.length; i += 1) {
            const path = svgData.paths[i];
            let code = SvgParser.toKanjiVGCodeById(path.id);
            code = Utility.zeroPadding(code, 5);
            try {
                const ret = await SvgParser.loadSvg(code);
                kvgData.push(ret);
            } catch(e) {
                console.log(`${code} is error.`);
            }          
        }
        
        const img = document.createElement('img');
        img.onload = (e) => {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            //ctx.drawImage(e.target, 0, 0, e.target.naturalWidth, e.target.naturalHeight);
            drawSvg(svgData, kvgData);  
            drawKvg(kvgData, svgData);
        }
        img.src = 'data:image/svg+xml;base64,' + btoa('<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n' + svgText);        

        // 
        function drawKvg(kvgData, svgData) {
            ctx.save();
            kvgData.forEach((data, i) => {
                //if(i === 0) {return;}
                ctx.strokeStyle = 'blue';
                ctx.fillStyle = 'blue';
                ctx.lineWidth = 2;
                data.paths.forEach(path => {
                    ctx.beginPath();

                    path.curvesArray.forEach(curves => {
                        curves.forEach((curve, j) => { 
                        //    curve.path(ctx, j === 0); 
                        });
                    });

                    ctx.stroke();
                });

                ctx.strokeStyle = 'pink';
                const r = data.rect;
                //ctx.strokeRect(r.x, r.y, r.width, r.height);

            });
            ctx.restore();
        }
        // svgDataに基づいて描画
        function drawSvg(svgData, kvgData) {
            
            ctx.save();

            // ビューポート変換行列
            Matrix.setTransform(ctx, svgData.vpMat);

            svgData.geoms.forEach((geom, gi) => {
                ctx.save();
                // オブジェクト変換行列をかける
                Matrix.transform(ctx, geom.mat);

                // 描画するpathを取得する
                const path = svgData.paths.find(p => p.c === geom.c);
                if(!path) { return; } // continue;                

                // 描画する
                ctx.strokeStyle = 'green';
                ctx.fillStyle = 'green';
                ctx.lineWidth = 10;
                ctx.beginPath();

                path.curvesArray.forEach(curves => {
                    curves.forEach((curve, i) => { 
                //        curve.path(ctx, i === 0); 
                    });
                });

                ctx.closePath();
                ctx.fill();

                const rect = path.rect;
                //ctx.strokeStyle = 'red';
                //ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);

                //ctx.fillStyle = 'pink';
                //Utility.fillCircle(ctx, { x: rect.x, y: rect.y }, 100);
                //Utility.fillCircle(ctx, { x: rect.x + rect.width, y: rect.y + rect.height }, 100);

                ctx.restore();                 
            });

            ctx.restore();

            ctx.save();

            svgData.geoms.forEach((geom, gi) => {

                // 描画するpathを取得する
                const path = svgData.paths.find(p => p.c === geom.c);
                if(!path) { return; } // continue;       

                const mat = Matrix.multiply(svgData.vpMat, geom.mat);

                // MathJax のgeom.rectをスクリーン座標系へ変換する
                const screenRect = Matrix.multiplyRect(mat, path.rect);
                ctx.fillStyle = 'pink';
                let p0 = { x: screenRect.x, y: screenRect.y }; 
                //Utility.fillCircle(ctx, p0, 5);

                let p1 = { x: screenRect.x + screenRect.width, y: screenRect.y + screenRect.height };
                //Utility.fillCircle(ctx, p1, 5);

                // geom に対応する kvg 用のコードを取得する
                const kvgCode = Utility.zeroPadding(geom.c, Define.SVG_FILE_NAME_LENGTH);
                console.log(kvgCode);

                // get kvg paths
                const data = kvgData.find(data => data.c === kvgCode); 
                if(!data) { 
                    console.log('kvg paths are not found.');
                    return;
                }
                const kvgPaths = data.paths;
                console.log(kvgPaths);

                // path の矩形を事前に計算しておく
                const kvgRect = data.rect;
                const newKvgRect = Utility.fitVerticalRect(screenRect, kvgRect);

                console.log('screenRect', screenRect);
                console.log('kvgRect', kvgRect);
                console.log('newKvgRect', newKvgRect);
                // 変換行列を求める
                const trans = Matrix.translate(-newKvgRect.x, -newKvgRect.y);
                const scale = Matrix.scale(screenRect.width / newKvgRect.width, screenRect.height / newKvgRect.height);
                const revTrans = Matrix.translate(screenRect.x, screenRect.y);

                let newMat = Matrix.multiply(scale, trans);
                newMat = Matrix.multiply(revTrans, newMat);

                const tempRect = Matrix.multiplyRect(newMat, newKvgRect);
                console.log('tempRect', tempRect);

                ctx.save();

                Matrix.setTransform(ctx, newMat);

                ctx.strokeStyle = 'blue';
                ctx.fillStyle = 'blue';
                ctx.lineWidth = 2;
                data.paths.forEach(path => {
                    ctx.beginPath();

                    path.curvesArray.forEach(curves => {
                        curves.forEach((curve, j) => { 
                            curve.path(ctx, j === 0); 
                        });
                    });

                    ctx.stroke();
                });

                ctx.restore();
                
            });

            ctx.restore();
        }
    }
});
</script>
<style>
#textarea {
	width: 600px;
	height: 200px;
    font-size: 18px;
}
#canvas {
  border: 1px solid #eeeeee;
}
</style>
</head>
<body>
	<textarea id="textarea">\huge{\begin{eqnarray}
2
\end{eqnarray}}</textarea><br>
	<input id="display-checkbox" type="checkbox" checked="true"/><label for="display-checkbox">display</label>    
    <button id="button">tex2svg</button>
    &nbsp;&nbsp;
    <a href="input-tex2svg.html">sample page</a><br><br>
	<canvas id="canvas" width="600" height="300"></canvas>
</body>
</html>
