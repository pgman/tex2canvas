<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tex To Canvas</title>
<script id="MathJax-script" async src="js/tex-svg-full.js"></script>
<script src="js/define.js"></script>
<script src="js/matrix.js"></script>
<script src="js/svg-parser.js"></script>
<script src="js/curve.js"></script>
<script src="js/utility.js"></script>
<script src="js/min-max.js"></script>
<script src="js/pixel.js"></script>
<script src="js/vector.js"></script>
<script src="js/seedrandom.min.js"></script>
<script src="js/app-svg.js"></script>
<script src="js/settings.js"></script>
<script src="js/controller.js"></script>
<script src="js/model.js"></script>
<script src="js/view.js"></script>
<script src="js/mathjax-svg.js"></script>
<script>
document.addEventListener('DOMContentLoaded', async () => {

    attachEvents();

    Settings.load('tex2canvas-settings');
    Settings.createHtml('#settings-wrapper');
    Settings.attachEvents();    

    Controller.init();
    await Model.init();
    View.init();    
});
async function load() {
    Model.datas = await loadDatas(); 
    if(Model.datas.length === 0) { return; }
    drawDatas(Model.datas); 
    console.time('getAnimDatas');
    Model.animDatas = getAnimDatas(Model.datas);
    console.timeEnd('getAnimDatas');
}
function play() {
    if(Model.animDatas.length === 0) { return; }
    // 初期化
    let animCount = 0;
    let animCanvasArray = [];
    let animCtxArray = [];
    let animImageDataArray = [];
    let rectArray = [];
    Model.animDatas.forEach(datas => {
        datas.forEach(data => {
            const animCanvas = Utility.createCanvas(data.rect.width, data.rect.height);
            const animCtx = animCanvas.getContext('2d');
            const animImageData = animCtx.getImageData(0, 0, animCtx.canvas.width, animCtx.canvas.height);
            
            animCanvasArray.push(animCanvas);
            animCtxArray.push(animCtx);    
            animImageDataArray.push(animImageData);       
            rectArray.push(data.rect);     
        });
    });
    let chalkPos = { x: 0, y: 0, };
    let chalkAnchorPos = { x: 101, y: 26, };

    let moveLastFlag = false;
    let moveDataIndex = -1;
    let moveMaxCount = 30;
    let moveCount = 30;
    let moveStartPos = { x: 300, y: 300, };
    let moveEndPos = Model.animDatas[0][0].animArray[0].pos; 
    
    if(Model.animIntervalId !== -1) {
        clearInterval(Model.animIntervalId);
        Model.animIntervalId = -1;
    }
    
    Model.animIntervalId = setInterval(() => {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        ctx.reset();
        ctx.drawImage(Model.blackBoardImg, 0, 0);
        if(moveCount > 0) {
            const moveVec = Vector.subtract(moveEndPos, moveStartPos);
            const rate = (moveMaxCount - moveCount) / moveMaxCount;
            chalkPos.x = moveStartPos.x + moveVec.x * rate;
            chalkPos.y = moveStartPos.y + moveVec.y * rate;
            for(let i = 0; i < animCanvasArray.length; i += 1) {
                const animCanvas = animCanvasArray[i];
                const rect = rectArray[i];
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, rect.x, rect.y);
                ctx.drawImage(animCanvas, 0, 0);
                ctx.restore();
            }
            ctx.drawImage(Model.chalkImg, chalkPos.x - chalkAnchorPos.x, chalkPos.y - chalkAnchorPos.y);
            moveCount -= 1;
            if(moveCount <= 0 && moveLastFlag) {
                clearInterval(Model.animIntervalId);
                Model.animIntervalId = -1;
            }
            return;
        }
        // animCtxArrayを更新        
        let elmCount = 0;
        let dataIndex = 0;
        let escapeFlag = false;
        for(let i = 0; i < Model.animDatas.length; i += 1) {
            for(let j = 0; j < Model.animDatas[i].length; j += 1) {
                for(let k = 0; k < Model.animDatas[i][j].animArray.length; k += 1) {
                    const animData = Model.animDatas[i][j];
                    const indexes = animData.animArray[k].indexes;
                    const imageData = animData.imageData;
                    if(animCount <= elmCount) {
                        const animImageData = animImageDataArray[dataIndex];
                        const data = animImageData.data;
                        indexes.forEach(l => {
                            data[l * 4 + 0] = imageData.data[l * 4 + 0];
                            data[l * 4 + 1] = imageData.data[l * 4 + 1];
                            data[l * 4 + 2] = imageData.data[l * 4 + 2];
                            data[l * 4 + 3] = imageData.data[l * 4 + 3];
                        });
                        animCtxArray[dataIndex].putImageData(animImageData, 0, 0);
                        chalkPos = JSON.parse(JSON.stringify(animData.animArray[k].pos));
                        if(k === Model.animDatas[i][j].animArray.length - 1) {
                            moveStartPos.x = chalkPos.x;
                            moveStartPos.y = chalkPos.y;
                            if(j !== Model.animDatas[i].length - 1) {
                                moveEndPos = Model.animDatas[i][j + 1].animArray[0].pos;
                                const dist = Vector.dist(moveStartPos, moveEndPos);
                                let count = Math.round(dist / Settings.pps);
                                if(dist > 200) {
                                    count = Math.round(dist / 12);
                                }
                                moveMaxCount = count;
                                moveCount = count;
                            } else if(i !== Model.animDatas.length - 1) {
                                moveEndPos = Model.animDatas[i + 1][0].animArray[0].pos;
                                const dist = Vector.dist(moveStartPos, moveEndPos);
                                let count = Math.round(dist / Settings.pps);
                                if(dist > 200) {
                                    count = Math.round(dist / 12);
                                }
                                moveMaxCount = count;
                                moveCount = count;
                            } else {
                                moveEndPos = { x: 1000, y: moveStartPos.y, };
                                moveMaxCount = 30;
                                moveCount = 30;
                                moveLastFlag = true;
                            }
                        }
                        escapeFlag = true;
                    }            
                    if(escapeFlag) { break; }
                    elmCount++; 
                }    
                if(escapeFlag) { break; }
                dataIndex += 1; 
            }
            if(escapeFlag) { break; }
        }
        animCount++;

        for(let i = 0; i < animCanvasArray.length; i += 1) {
            const animCanvas = animCanvasArray[i];
            const rect = rectArray[i];
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, rect.x, rect.y);
            ctx.drawImage(animCanvas, 0, 0);
            ctx.restore();
        }
        // chalk        
        ctx.drawImage(Model.chalkImg, chalkPos.x - chalkAnchorPos.x, chalkPos.y - chalkAnchorPos.y); // 101, 26
    }, 1000 / Settings.fps);
}
function getAnimDatas(datas) {
    const ret = [];
    datas.forEach(data => {
        if(data.type === 'app') {
            const strokeArray = [];
            data.curvesArray.forEach((curves, i) => {
                let posArray = [];
                curves.forEach((curve, j) => { 
                    let points = curve.divide();
                    const transMat = Matrix.translate(Settings.padding, Settings.padding);
                    const scaleMat = Matrix.scale(Settings.scale, Settings.scale);
                    let mat = Matrix.multiply(scaleMat, data.mat);
                    mat = Matrix.multiply(transMat, mat);
                    points = points.map(p => Matrix.multiplyVec(mat, p));
                    if(posArray.length === 0) {
                        posArray = posArray.concat(points);
                    } else {// 既に登録されている場合
                        // 前の最後の線分の終点と、今回の最初の線分の始点が一致する可能性がある
                        const last = posArray[posArray.length - 1];
                        const start = points[0];
                        const equal = Vector.equals(last, start);
                        if(equal) {
                            points.shift();
                        } 
                        posArray = posArray.concat(points);
                    }
                });
                const pixelData = Pixel.getAnimationPixelData({
                    posArray: posArray, 
                    lineWidth: Settings.lineWidth, 
                    strokeStyle: { r: Settings.color.r, g: Settings.color.g, b: Settings.color.b, a: Settings.color.a, }, 
                    boundaryThreshold: Settings.boundaryThreshold,   
                    internalThreshold: Settings.internalThreshold,
                    sigma: Settings.sigma, 
                    pps: Settings.pps,  
                    removeType: 'zero', // 'zero' or 'random'
                });
                strokeArray.push(pixelData);
            });
            ret.push(strokeArray);
        }
    });
    return ret;
}
function drawDatas(datas) {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.reset();
    ctx.drawImage(Model.blackBoardImg, 0, 0);    
    datas.forEach(data => { drawData(ctx, data); });
}
function drawData(ctx, data) {
    const transMat = Matrix.translate(Settings.padding, Settings.padding);
    const scaleMat = Matrix.scale(Settings.scale, Settings.scale);
    let mat = Matrix.multiply(scaleMat, data.mat);
    mat = Matrix.multiply(transMat, mat);

    ctx.save();

    Matrix.setTransform(ctx, mat);

    ctx.strokeStyle = 'white';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = Settings.lineWidth / mat[0];
    if(data.type === 'app') {
        ctx.beginPath();
        data.curvesArray.forEach((curves, i) => {
            curves.forEach((curve, j) => { 
                curve.path(ctx, j === 0); 
            });
        });
        ctx.stroke();
    } else {
        data.kvg.paths.forEach(path => {                
            ctx.beginPath();
            path.curvesArray.forEach((curves, i) => {
                curves.forEach((curve, j) => { 
                    curve.path(ctx, j === 0); 
                });
            });
            ctx.stroke();
        });
    }

    ctx.restore();
}
async function loadDatas() {
    // 設定内容の保存
    Settings.save('tex2canvas-settings');
    // AppSvgの保存
    AppSvg.save('tex2canvas', Model.avgData);
    // 数式(MathJax用)を保存
    localStorage.setItem('tex2canvas-equation', Model.equation);
    
    // svg に変換(MathJax.tex2svg を呼ぶだけ)
    Model.svgText = MathJaxSvg.getMathJaxSvgText(Model.equation, Model.display);    
    console.log(Model.svgText);
    // エラーがないか調べる
    const error = MathJaxSvg.getError(Model.svgText);
    if(error) {
        alert(error);
        return;
    }
    // パースする
    Model.mvgData = MathJaxSvg.parseMathJaxSvg(Model.svgText);

    const kvgData = [];
    for(let i = 0; i < Model.mvgData.paths.length; i += 1) {
        const path = Model.mvgData.paths[i];
        let code = SvgParser.toKanjiVGCodeById(path.id);
        code = Utility.zeroPadding(code, 5);
        try {
            if(Model.kvgCodes.indexOf(code) >= 0) {
                const ret = await SvgParser.loadSvg(code);
                kvgData.push(ret);
            } else {
                console.log(`${code} is not defined.`);
            }                
        } catch(e) {
            console.log(`${code} is error.`);
            throw 'error';
        }          
    }

    return getDatas(Model.mvgData, kvgData);
}
function drawSvg(ctx, mvgData, options) {
    ctx.save();

    const transMat = Matrix.translate(Settings.padding, Settings.padding);
    const scaleMat = Matrix.scale(Settings.scale, Settings.scale);

    // ビューポート変換行列
    Matrix.setTransform(ctx, transMat);

    Matrix.transform(ctx, scaleMat);

    Matrix.transform(ctx, mvgData.vpMat);

    mvgData.shapes.forEach(shape => {
        ctx.save();
        // オブジェクト変換行列をかける
        Matrix.transform(ctx, shape.mat);

        // 描画するpathを取得する
        const path = mvgData.paths.find(p => p.c === shape.c);
        if(!path) { return; } // continue;
        
        if(options.fillChar) {// 文字を塗る
            ctx.fillStyle = options.fillStyle ? options.fillStyle : 'green';
            ctx.lineWidth = 10;
            ctx.beginPath();
            path.curvesArray.forEach(curves => {
                curves.forEach((curve, i) => { 
                    curve.path(ctx, i === 0); 
                });
            });
            ctx.closePath();
            ctx.fill();
        }       
        
        if(options.strokeRect) {
            const rect = path.rect;
            ctx.strokeStyle = 'red';
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        }               

        ctx.restore();                 
    });

    ctx.restore();
}
function getDatas(mvgData, kvgData) {
    const ret = [];

    // ret に kvgDataのインデックスと変換行列を格納していく
    mvgData.shapes.forEach(shape => {
        if(shape.tagName === 'use') {// <use>
            // 描画するpathを取得する
            const path = mvgData.paths.find(p => p.c === shape.c);
            if(!path) { return; } // continue;       

            // MathJax のshape.rectをスクリーン座標系へ変換する
            const mat = Matrix.multiply(mvgData.vpMat, shape.mat);                
            const screenRect = Matrix.multiplyRect(mat, path.rect); // スクリーン座標系の矩形

            const id = shape.xlinkHref.substring(1);
            let kvgCode = SvgParser.toKanjiVGCodeById(id);
            kvgCode = Utility.zeroPadding(kvgCode, Define.SVG_FILE_NAME_LENGTH);
            let splits = id.split('-');
            const avgCode = splits[4]; 

            if(Model.avgData[avgCode]) {
                // calc rect
                const curvesArray = Model.avgData[avgCode].map(curves => {
                    return curves.map(elm => new Curve(elm.points));
                });
                const rect = getCurvesArrayRect(curvesArray);
                // push data
                ret.push({ type: 'app', curvesArray, mat: getNewMatrix(screenRect, rect), });
            } else {
                // get kvg paths
                const data = kvgData.find(data => data.c === kvgCode); 
                if(!data) { 
                    console.log('kvg paths are not found.');
                    return;
                }
                // push data
                ret.push({ type: 'kvg', kvg: data, mat: getNewMatrix(screenRect, data.rect), });
            }
        } else if(shape.tagName === 'rect') {
            // MathJax のshape.rectをスクリーン座標系へ変換する
            const mat = Matrix.multiply(mvgData.vpMat, shape.mat);                
            const screenRect = Matrix.multiplyRect(mat, shape.rect); // スクリーン座標系の矩形
            const curvesArray = [
                [new Curve([{ x: 0, y: 0 }, { x: 30, y: 0 }, { x: 60, y: 0 }, { x: 90, y: 0 }]) ]
            ];
            const rect = getCurvesArrayRect(curvesArray);
                
            ret.push({ type: 'app', curvesArray, mat: getNewMatrix(screenRect, rect), });
        }                
    });

    return ret;
}
function attachEvents() {
    // tex2svg ボタン押下時の処理
    document.querySelector('#tex2svg-button').addEventListener('click', async () => {
        Settings.onChange();
        load();
    });

    // play ボタン押下時の処理
    document.querySelector('#play-button').addEventListener('click', async () => {
        play();
    });    

    // テキストでCtrl + Sした時の処理
    document.querySelector('#textarea').addEventListener('keydown', async e => {
        if(e.ctrlKey && e.key === 's') {
            e.preventDefault(); // Prevent the Save dialog to open
            Settings.onChange();
        }
    });
}
function getCurvesArrayRect(curvesArray) {
    MinMax.save();
    MinMax.init();        
    curvesArray.forEach(curves => {
        curves.forEach(curve => {
            const rect = curve.rect();
            MinMax.add({ x: rect.x, y: rect.y, });
            MinMax.add({ x: rect.x + rect.width, y: rect.y + rect.height, });
        });
    });      
    const rect = MinMax.getRect();
    MinMax.restore();
    return rect;
}
function getNewMatrix(screenRect, rect) {
    let aspect;
    if(rect.height < 0.01) {
        aspect = 100;
    } else {
        aspect= rect.width / rect.height;
    }
    let newRect = Utility.fitVerticalRect(screenRect, rect);
    if(aspect > 5) {
        newRect = Utility.fitHorizontalRect(screenRect, rect);                        
    }

    // 変換行列を求める
    const trans = Matrix.translate(-newRect.x, -newRect.y);
    const scale = Matrix.scale(screenRect.width / newRect.width, screenRect.height / newRect.height);
    const revTrans = Matrix.translate(screenRect.x, screenRect.y);

    let newMat = Matrix.multiply(scale, trans);
    newMat = Matrix.multiply(revTrans, newMat);
    return newMat;
}
async function drawBackCanvas(selector, imgPath) {
    const img = await Utility.loadImage(imgPath);    
    const canvas = document.querySelector(selector);
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
}
</script>
<style>
#textarea {
	width: 600px;
	height: 160px;
    font-size: 18px;
}
.mb-8 {
    margin-bottom: 8px;
}
label {
    -webkit-user-select: none; /* Safari */
    -ms-user-select: none; /* IE 10 and IE 11 */
    user-select: none; /* Standard syntax */
}
.draw-canvas {
    position: absolute;
    left: 8px;
    top: 320px;
}
</style>
</head>
<body>
    <div class="mb-8">
	    <textarea id="textarea"></textarea>
    </div>
    <div class="mb-8">
	    <input id="display-checkbox" type="checkbox" checked="true"/><label for="display-checkbox">display</label>    
        <button id="tex2svg-button">tex2svg</button>
        &nbsp;&nbsp;
        <button id="play-button">play</button>
        &nbsp;&nbsp;
        <button id="save-app-svg-button">save app svg</button>
        &nbsp;&nbsp;
        <button id="load-app-svg-button">load app svg</button>
        &nbsp;&nbsp;
        <a href="char-def.html">char-def</a>&nbsp;&nbsp;
        <a href="my-chalk.html">my-chalk</a>&nbsp;&nbsp;
        <a href="input-tex2svg.html">sample page</a>
    </div>
    <div id="settings-wrapper" class="mb-8">
    </div>
    <div id="show-wrapper" class="mb-8">
        <label for="mvg-check">
            <input type="checkbox" id="mvg-check" />MVG
        </label>
        <label for="mvg-rect-check">
            <input type="checkbox" id="mvg-rect-check" />MVG-Rect
        </label>
        <label for="kvg-check">
            <input type="checkbox" id="kvg-check" />KVG
        </label>
        <label for="kvg-rect-check">
            <input type="checkbox" id="kvg-rect-check" />KVG-Rect
        </label>
        <label for="avg-check">
            <input type="checkbox" id="avg-check" />AVG
        </label>
        <label for="avg-rect-check">
            <input type="checkbox" id="avg-rect-check" />AVG-Rect
        </label>
    </div>
    <div id="canvas-area">
        <!-- 黒板用canvas -->
        <canvas id="back-canvas" class="draw-canvas" width="1024" height="576"></canvas>
        <!-- アニメーション用canvas -->
        <canvas id="canvas" class="draw-canvas" width="1024" height="576"></canvas>
        <!-- avg -->
        <canvas id="avg-canvas" class="draw-canvas" width="1024" height="576"></canvas>
        <!-- kvg -->
        <canvas id="kvg-canvas" class="draw-canvas" width="1024" height="576"></canvas>
        <!-- mvg -->
        <canvas id="mvg-canvas" class="draw-canvas" width="1024" height="576"></canvas>
    </div>	
</body>
</html>
