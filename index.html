<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tex To Canvas</title>
<script id="MathJax-script" async src="js/tex-svg-full.js"></script>
<script src="js/define.js"></script>
<script src="js/matrix.js"></script>
<script src="js/svg-parser.js"></script>
<script src="js/curve.js"></script>
<script src="js/utility.js"></script>
<script src="js/min-max.js"></script>
<script src="js/pixel.js"></script>
<script src="js/vector.js"></script>
<script src="js/seedrandom.min.js"></script>
<script>
//////////////////////////
// 言葉の定義
//////////////////////////

settings = {
    lineWidth: 5,
    sigma: 2,
    boundaryThreshold: 0.1,
    internalThreshold: 0.05,
    scale: 3,
    padding: 20,
    pps: 3,
};

const MIN_LINE_WIDTH = 1;
const MAX_LINE_WIDTH = 20;
const STEP_LINE_WIDTH = 1;

const MIN_SIGMA = 1;
const MAX_SIGMA = 4;
const STEP_SIGMA = 0.25;

const THRESHOLD_ARRAY = [ 0.001, 0.002, 0.005, 0.01, 0.02, 0.03, 0.04, 0.05, 0.1, 0.2, 0.5 ];

const MIN_SCALE = 1;
const MAX_SCALE = 5;
const STEP_SCALE = 0.5;

const MIN_PADDING = 0;
const MAX_PADDING = 50;
const STEP_PADDING = 5;

const MIN_PPS = 1;
const MAX_PPS = 20;
const STEP_PPS = 1;

const STRING_COLOR = 'rgb(255, 255, 255)';
const BLACK_BOARD_IMAGE_PATH = 'images/black_board.jpg';

// Mathjaxの返すSVG => MVG
// KanjiVGのデータ => KVG
// アプリで定義されたSVG => AVG

let blackBoardImg = null;
let datas = [];
let animDatas = [];

// KanjiVGのファイル名から.svgを除いたコードの配列
let kvgCodes = null;

// アプリで定義した曲線群
let avgData = {};
let svgData = null;

let animIntervalId = -1;

document.addEventListener('DOMContentLoaded', async () => {

    attachEvents();

    // init select

    // settings
    const jsonSettings = localStorage.getItem('tex2canvas-settings');
    if(jsonSettings) {
        settings = JSON.parse(jsonSettings);
    }

    let html = '';
    for(let i = MIN_LINE_WIDTH; i <= MAX_LINE_WIDTH; i += STEP_LINE_WIDTH) {
        html += `<option value="${i}" ${i === settings.lineWidth ? 'selected' : ''}>${i}px</option>`;
    }
    document.querySelector('#line-width-select').innerHTML = html;

    html = '';
    for(let i = MIN_SIGMA; i <= MAX_SIGMA; i += STEP_SIGMA) {
        html += `<option value="${i}" ${i === settings.sigma ? 'selected' : ''}>${i}px</option>`;
    }
    document.querySelector('#sigma-select').innerHTML = html;

    html = '';
    THRESHOLD_ARRAY.forEach(elm => {
        html += `<option value="${elm}" ${elm === settings.boundaryThreshold ? 'selected' : ''}>${(elm * 100).toFixed(2) + '%'}</option>`;
    });
    document.querySelector('#boundary-threshold-select').innerHTML = html;

    html = '';
    THRESHOLD_ARRAY.forEach(elm => {
        html += `<option value="${elm}" ${elm === settings.internalThreshold ? 'selected' : ''}>${(elm * 100).toFixed(2) + '%'}</option>`;
    });
    document.querySelector('#internal-threshold-select').innerHTML = html;

    html = '';
    for(let i = MIN_PPS; i <= MAX_PPS; i += STEP_PPS) {
        html += `<option value="${i}" ${i === settings.pps ? 'selected' : ''}>${i}pps</option>`;
    }
    document.querySelector('#pps-select').innerHTML = html;

    html = '';
    for(let i = MIN_SCALE; i <= MAX_SCALE; i += STEP_SCALE) {
        html += `<option value="${i}" ${i === settings.scale ? 'selected' : ''}>x ${i}</option>`;
    }
    document.querySelector('#scale-select').innerHTML = html;

    html = '';
    for(let i = MIN_PADDING; i <= MAX_PADDING; i += STEP_PADDING) {
        html += `<option value="${i}" ${i === settings.padding ? 'selected' : ''}>${i}px</option>`;
    }
    document.querySelector('#padding-select').innerHTML = html;

    // select event handler
    document.querySelector('#line-width-select').addEventListener('change', onChange);
    document.querySelector('#sigma-select').addEventListener('change', onChange);
    document.querySelector('#boundary-threshold-select').addEventListener('change', onChange);
    document.querySelector('#internal-threshold-select').addEventListener('change', onChange);
    document.querySelector('#pps-select').addEventListener('change', onChange);
    document.querySelector('#scale-select').addEventListener('change', onChange);
    document.querySelector('#padding-select').addEventListener('change', onChange);

    // text
    const equation = localStorage.getItem('tex2canvas-equation');
    if(equation) {
        document.querySelector('#textarea').value = equation;
    }    

    try {
        const res = await fetch(Define.KVG_FILE);
        const data = await res.text();
        kvgCodes = data.split('\r\n').filter(d => d).map(d => d.replaceAll('.svg', ''));
    } catch(e) {

    }    

    const jsonStr = localStorage.getItem('tex2canvas');
    if(jsonStr) {
        avgData = JSON.parse(jsonStr);
    }

    blackBoardImg = await Utility.loadImage(BLACK_BOARD_IMAGE_PATH);

    load();
});
async function load() {
    datas = await loadDatas();   

    // for debug
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.reset();
    //ctx.drawImage(blackBoardImg, 0, 0);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    //drawSvg(ctx, svgData, { fillChar: true, strokeRect: true, });
    drawDatas(datas); 
    animDatas = getAnimDatas(datas);
    if(animIntervalId !== -1) {
        clearInterval(animIntervalId);
    }
    // 初期化
    let animCount = 0;
    let animCanvasArray = [];
    let animCtxArray = [];
    let animImageDataArray = [];
    let rectArray = [];
    animDatas.forEach(datas => {
        datas.forEach(data => {
            const animCanvas = Utility.createCanvas(data.rect.width, data.rect.height);
            const animCtx = animCanvas.getContext('2d');
            const animImageData = animCtx.getImageData(0, 0, animCtx.canvas.width, animCtx.canvas.height);
            
            animCanvasArray.push(animCanvas);
            animCtxArray.push(animCtx);    
            animImageDataArray.push(animImageData);       
            rectArray.push(data.rect);     
        });
    });
    animIntervalId = setInterval(() => {
        // animCtxArrayを更新
        let elmCount = 0;
        let dataIndex = 0;
        let escapeFlag = false;
        for(let i = 0; i < animDatas.length; i += 1) {
            for(let j = 0; j < animDatas[i].length; j += 1) {
                for(let k = 0; k < animDatas[i][j].indexesArray.length; k += 1) {
                    const animData = animDatas[i][j];
                    const indexes = animData.indexesArray[k];
                    const imageData = animData.imageData;
                    if(animCount <= elmCount) {
                        const animImageData = animImageDataArray[dataIndex];
                        const data = animImageData.data;
                        indexes.forEach(l => {
                            data[l * 4 + 0] = imageData.data[l * 4 + 0];
                            data[l * 4 + 1] = imageData.data[l * 4 + 1];
                            data[l * 4 + 2] = imageData.data[l * 4 + 2];
                            data[l * 4 + 3] = imageData.data[l * 4 + 3];
                        });
                        animCtxArray[dataIndex].putImageData(animImageData, 0, 0);
                        escapeFlag = true;
                    }
                    if(escapeFlag) { break; }
                    elmCount++;                    
                }
                if(escapeFlag) { break; }
                dataIndex += 1;
            }
            if(escapeFlag) { break; }
        }
        animCount++;

        for(let i = 0; i < animCanvasArray.length; i += 1) {
            const animCanvas = animCanvasArray[i];
            const rect = rectArray[i];
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, rect.x, rect.y);
            ctx.drawImage(animCanvas, 0, 0);
            ctx.restore();
        }
    }, 1000 / 60);
}
function getAnimDatas(datas) {
    const ret = [];
    datas.forEach(data => {
        if(data.type === 'app') {
            const strokeArray = [];
            data.curvesArray.forEach((curves, i) => {
                let posArray = [];
                curves.forEach((curve, j) => { 
                    let points = curve.divide();
                    const transMat = Matrix.translate(settings.padding, settings.padding);
                    const scaleMat = Matrix.scale(settings.scale, settings.scale);
                    let mat = Matrix.multiply(scaleMat, data.mat);
                    mat = Matrix.multiply(transMat, mat);
                    points = points.map(p => Matrix.multiplyVec(mat, p));
                    if(posArray.length === 0) {
                        posArray = posArray.concat(points);
                    } else {// 既に登録されている場合
                        // 前の最後の線分の終点と、今回の最初の線分の始点が一致する可能性がある
                        const last = posArray[posArray.length - 1];
                        const start = points[0];
                        const equal = Vector.equalsTo(last, start);
                        if(equal) {
                            points.shift();
                        } 
                        posArray = posArray.concat(points);
                    }
                });
                const pixelData = Pixel.getAnimationPixelData({
                    posArray: posArray, 
                    lineWidth: settings.lineWidth, 
                    strokeStyle: { r: 255, g: 255, b: 255, a: 255 },   //strokeStyle, 
                    boundaryThreshold: settings.boundaryThreshold,   
                    internalThreshold: settings.internalThreshold,
                    sigma: settings.sigma, 
                    pps: settings.pps,  
                    removeType: 'zero', // 'zero' or 'random'
                });
                strokeArray.push(pixelData);
            });
            ret.push(strokeArray);
        }
    });
    return ret;
}
function drawAnimDatas(animDatas) {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    datas.forEach(data => { drawData(ctx, data); });
}
function drawAnimData(ctx, animData) {
    ctx.save();
    ctx.restore();
}
function drawDatas(datas) {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.reset();
    ctx.drawImage(blackBoardImg, 0, 0);
    //datas.forEach(data => { drawData(ctx, data); });
}
function drawData(ctx, data) {
    const transMat = Matrix.translate(settings.padding, settings.padding);
    const scaleMat = Matrix.scale(settings.scale, settings.scale);
    let mat = Matrix.multiply(scaleMat, data.mat);
    mat = Matrix.multiply(transMat, mat);

    ctx.save();

    Matrix.setTransform(ctx, mat);

    ctx.strokeStyle = 'white';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = settings.lineWidth / mat[0];
    if(data.type === 'app') {
        ctx.beginPath();
        data.curvesArray.forEach((curves, i) => {
            curves.forEach((curve, j) => { 
                curve.path(ctx, j === 0); 
            });
        });
        ctx.stroke();
    } else {
        data.kvg.paths.forEach(path => {                
            ctx.beginPath();
            path.curvesArray.forEach((curves, i) => {
                curves.forEach((curve, j) => { 
                    curve.path(ctx, j === 0); 
                });
            });
            ctx.stroke();
        });
    }

    ctx.restore();
}
async function loadDatas() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    // 設定内容
    localStorage.setItem('tex2canvas-settings', JSON.stringify(settings));
    // 数式(MathJax用)
    const equation = document.querySelector('#textarea').value;
    localStorage.setItem('tex2canvas-equation', equation);
    const display = document.querySelector('#display-checkbox').checked;
    // svgに変換
    const svgText = SvgParser.getMathJaxSvgText(equation, display);
    // パースする
    svgData = SvgParser.parseMathJaxSvg(svgText);

    const kvgData = [];
    for(let i = 0; i < svgData.paths.length; i += 1) {
        const path = svgData.paths[i];
        let code = SvgParser.toKanjiVGCodeById(path.id);
        code = Utility.zeroPadding(code, 5);
        try {
            if(kvgCodes.indexOf(code) >= 0) {
                const ret = await SvgParser.loadSvg(code);
                kvgData.push(ret);
            } else {
                console.log(`${code} is not defined.`);
            }                
        } catch(e) {
            console.log(`${code} is error.`);
            throw 'error';
        }          
    }

    return getDatas(svgData, kvgData);
}
function drawSvg(ctx, svgData, options) {
    ctx.save();

    const transMat = Matrix.translate(settings.padding, settings.padding);
    const scaleMat = Matrix.scale(settings.scale, settings.scale);

    // ビューポート変換行列
    Matrix.setTransform(ctx, transMat);

    Matrix.transform(ctx, scaleMat);

    Matrix.transform(ctx, svgData.vpMat);

    svgData.shapes.forEach(shape => {
        ctx.save();
        // オブジェクト変換行列をかける
        Matrix.transform(ctx, shape.mat);

        // 描画するpathを取得する
        const path = svgData.paths.find(p => p.c === shape.c);
        if(!path) { return; } // continue;
        
        if(options.fillChar) {// 文字を塗る
            ctx.fillStyle = options.fillStyle ? options.fillStyle : 'green';
            ctx.lineWidth = 10;
            ctx.beginPath();
            path.curvesArray.forEach(curves => {
                curves.forEach((curve, i) => { 
                    curve.path(ctx, i === 0); 
                });
            });
            ctx.closePath();
            ctx.fill();
        }       
        
        if(options.strokeRect) {
            const rect = path.rect;
            ctx.strokeStyle = 'red';
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        }               

        ctx.restore();                 
    });

    ctx.restore();
}
function getDatas(svgData, kvgData) {
    const ret = [];

    // ret に kvgDataのインデックスと変換行列を格納していく
    svgData.shapes.forEach(shape => {
        if(shape.tagName === 'use') {// <use>
            // 描画するpathを取得する
            const path = svgData.paths.find(p => p.c === shape.c);
            if(!path) { return; } // continue;       

            // MathJax のshape.rectをスクリーン座標系へ変換する
            const mat = Matrix.multiply(svgData.vpMat, shape.mat);                
            const screenRect = Matrix.multiplyRect(mat, path.rect); // スクリーン座標系の矩形

            const id = shape.xlinkHref.substring(1);
            let kvgCode = SvgParser.toKanjiVGCodeById(id);
            kvgCode = Utility.zeroPadding(kvgCode, Define.SVG_FILE_NAME_LENGTH);
            let splits = id.split('-');
            const avgCode = splits[4]; 

            if(avgData[avgCode]) {
                // calc rect
                const curvesArray = avgData[avgCode].map(curves => {
                    return curves.map(elm => new Curve(elm.points));
                });
                const rect = getCurvesArrayRect(curvesArray);
                // push data
                ret.push({ type: 'app', curvesArray, mat: getNewMatrix(screenRect, rect), });
            } else {
                // get kvg paths
                const data = kvgData.find(data => data.c === kvgCode); 
                if(!data) { 
                    console.log('kvg paths are not found.');
                    return;
                }
                // push data
                ret.push({ type: 'kvg', kvg: data, mat: getNewMatrix(screenRect, data.rect), });
            }
        } else if(shape.tagName === 'rect') {
            // MathJax のshape.rectをスクリーン座標系へ変換する
            const mat = Matrix.multiply(svgData.vpMat, shape.mat);                
            const screenRect = Matrix.multiplyRect(mat, shape.rect); // スクリーン座標系の矩形
            const curvesArray = [
                [new Curve([{ x: 0, y: 0 }, { x: 30, y: 0 }, { x: 60, y: 0 }, { x: 90, y: 0 }]) ]
            ];
            const rect = getCurvesArrayRect(curvesArray);
                
            ret.push({ type: 'app', curvesArray, mat: getNewMatrix(screenRect, rect), });
        }                
    });

    return ret;
}
function attachEvents() {
    // ボタン押下時の処理
    document.querySelector('#button').addEventListener('click', async () => {
        load();
    });

    // テキストでCtrl + Sした時の処理
    document.querySelector('#textarea').addEventListener('keydown', async e => {
        if(e.ctrlKey && e.key === 's') {
            e.preventDefault(); // Prevent the Save dialog to open
            load();
        }
    });
}
async function onChange() {
    settings.lineWidth = Number(document.querySelector('#line-width-select').value);
    settings.sigma = Number(document.querySelector('#sigma-select').value);    
    settings.boundaryThreshold = Number(document.querySelector('#boundary-threshold-select').value);
    settings.internalThreshold = Number(document.querySelector('#internal-threshold-select').value);
    settings.pps = Number(document.querySelector('#pps-select').value);
    settings.scale = Number(document.querySelector('#scale-select').value);
    settings.padding = Number(document.querySelector('#padding-select').value);
    load();
}

function getCurvesArrayRect(curvesArray) {
    MinMax.save();
    MinMax.init();        
    curvesArray.forEach(curves => {
        curves.forEach(curve => {
            const rect = curve.rect();
            MinMax.add({ x: rect.x, y: rect.y, });
            MinMax.add({ x: rect.x + rect.width, y: rect.y + rect.height, });
        });
    });      
    const rect = MinMax.getRect();
    MinMax.restore();
    return rect;
}
function getNewMatrix(screenRect, rect) {
    let aspect;
    if(rect.height < 0.01) {
        aspect = 100;
    } else {
        aspect= rect.width / rect.height;
    }
    let newRect = Utility.fitVerticalRect(screenRect, rect);
    if(aspect > 5) {
        newRect = Utility.fitHorizontalRect(screenRect, rect);                        
    }

    // 変換行列を求める
    const trans = Matrix.translate(-newRect.x, -newRect.y);
    const scale = Matrix.scale(screenRect.width / newRect.width, screenRect.height / newRect.height);
    const revTrans = Matrix.translate(screenRect.x, screenRect.y);

    let newMat = Matrix.multiply(scale, trans);
    newMat = Matrix.multiply(revTrans, newMat);
    return newMat;
}
</script>
<style>
#textarea {
	width: 600px;
	height: 200px;
    font-size: 18px;
}
.mb-8 {
    margin-bottom: 8px;
}
</style>
</head>
<body>
    <div class="mb-8">
	    <textarea id="textarea"></textarea>
    </div>
    <div class="mb-8">
	    <input id="display-checkbox" type="checkbox" checked="true"/><label for="display-checkbox">display</label>    
        <button id="button">tex2svg</button>
        &nbsp;&nbsp;
        <a href="char-def.html">char-def</a>&nbsp;&nbsp;<a href="input-tex2svg.html">sample page</a>
    </div>
    <div class="mb-8">
        <div class="mb-8">
            lineWidth:&nbsp;
            <select id="line-width-select"></select>&nbsp;&nbsp;
            sigma:&nbsp;
            <select id="sigma-select"></select>&nbsp;&nbsp;
            boundary threshold:&nbsp;
            <select id="boundary-threshold-select"></select>&nbsp;&nbsp;
            internal threshold:&nbsp;
            <select id="internal-threshold-select"></select>&nbsp;&nbsp;
            px per second:&nbsp;
            <select id="pps-select"></select>&nbsp;&nbsp;
        </div>
        <div>
            scale:&nbsp;
            <select id="scale-select"></select>&nbsp;&nbsp;
            padding:&nbsp;
            <select id="padding-select"></select>&nbsp;&nbsp;
        </div>
    </div>
	<canvas id="canvas" width="1024" height="576"></canvas>
</body>
</html>
