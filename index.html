<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tex To Canvas</title>
<script id="MathJax-script" async src="js/tex-svg-full.js"></script>
<script src="js/define.js"></script>
<script src="js/matrix.js"></script>
<script src="js/svg-parser.js"></script>
<script src="js/curve.js"></script>
<script src="js/utility.js"></script>
<script>
/*
[bug]
・"備"がエラーが出てしまう 
   -> プロパティ内に半角スペースがあるのが原因かな？
   -> 半角スペースを削除したがダメ
   -> m(小文字)の処理がうまくできていない感じがする
*/
// 参考URL
// https://stackoverflow.com/questions/71031646/write-svg-latex-into-a-canvas-html
// 課題
// インラインの表示がうまくいかない
// もうね \begin{eqnarray}日本語x^2\\x^3\end{eqnarray}でいいと思うんだ
// textareaに色付けたいかな -> ace.jsでいけそう

// TODO 
// ・日本語入力したときはpathが取れない？
// ・なので日本語入力には対応しないでいいんじゃないかな？

// TODO 

/*
Mathjax demo
https://mathjax.github.io/MathJax-demos-web/input-tex2svg.html.html
display: boolean でインラインかどうかわ変えることができそう -> できた
ところで、$～$ や $$～$$は意味なさそう
*/

/**
 * 開発用TODO
 * ・16進数コードから漢字に変換するプログラムを作成する(http://d.hatena.ne.jp/yasuhallabo/20140211/1392131668) -> うまくいっていない(保留)
 *   https://gist.github.com/seekseep/e5c289791265dafee786640942ee2e4d -> これでもうまくいかない -> 16進数コードから日本語の復元がうまくいかない
 *   -> Bufferが使えるのはNodeのみなので、おそらくArrayBufferを使う
 * ・kvgをMathJaxのSvgの位置に合わせる
 * 
 * ・
 * ・rect 対応する
 * []について調べる
 * 行列の()は縦に長くなると複数のパスになる。これはうまく対応したところではある <- 長括弧対応
 * サイズを指定せずに svg の幅と高さを変えた方がよいかもしれない
 * そうすると、\bar{x} によるバーとのずれが無くなると思う
 * 
 * デモで動作させたい数式
 * \int \frac {\bf x}
 * アルファベット細字の大文字、小文字
 * アルファベット太字の大文字、小文字 
 * ギリシャ文字の大文字、小文字は定義する
 */

// うーん、mathjaxのsvgを解析した結果
// kanjivgのsvgを解析した結果の変数名を考えないといけない!!!

// <path d=""> なのであり、dを解析すると、曲線の配列の配列が出来上がる
// 曲線は curve であり、曲線の配列は curves、曲線の配列の配列は curvesArrayである

// <rect>

// 文字定義画面を作成する

// kanjivgのsvgはkvgと呼ぶ
// mathjaxのsvgはmvgと呼ぶ

// 初期の拡大率調査 => 現状hugeをつけないと文字サイズが小さい件を調査する

// KanjiVGのファイル名から.svgを除いたコードの配列
let kvgCodes = null;

document.addEventListener('DOMContentLoaded', async () => {

    attachEvents();

    try {
        const res = await fetch(Define.KVG_FILE);
        const data = await res.text();
        kvgCodes = data.split('\r\n').filter(d => d).map(d => d.replaceAll('.svg', ''));
    } catch(e) {

    }    

    function attachEvents() {
        // ボタン押下時の処理
        document.querySelector('#button').addEventListener('click', svg2canvas);

        // テキストでCtrl + Sした時の処理
        document.querySelector('#textarea').addEventListener('keydown', e => {
            if(e.ctrlKey && e.key === 's') {
                e.preventDefault(); // Prevent the Save dialog to open
                svg2canvas();   
            }
        });
    }

    async function svg2canvas() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        // 数式(MathJax用)
        const equation = document.querySelector('#textarea').value;
        const display = document.querySelector('#display-checkbox').checked;
        // svgに変換
        const svgText = SvgParser.getMathJaxSvgText(equation, display);
        //const svgText = await SvgParser.getMathJaxSvgTextAsync(equation, display);
        // パースする
        const svgData = SvgParser.parseMathJaxSvg(svgText);

        const kvgData = [];
        for(let i = 0; i < svgData.paths.length; i += 1) {
            const path = svgData.paths[i];
            let code = SvgParser.toKanjiVGCodeById(path.id);
            code = Utility.zeroPadding(code, 5);
            try {
                const ret = await SvgParser.loadSvg(code);
                kvgData.push(ret);
            } catch(e) {
                console.log(`${code} is error.`);
            }          
        }

        const datas = getDatas(svgData, kvgData);
        
        const img = document.createElement('img');
        img.onload = (e) => {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            //ctx.drawImage(e.target, 0, 0, e.target.naturalWidth, e.target.naturalHeight);
            //drawSvg(ctx, svgData, { fillChar: true, strokeRect: true }); 
            for(let i = 0; i < datas.length; i += 1) {
                drawData(ctx, datas[i]);
            }
        }
        img.src = 'data:image/svg+xml;base64,' + btoa('<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n' + svgText);        

        function drawSvg(ctx, svgData, options) {
            ctx.save();

            // ビューポート変換行列
            Matrix.setTransform(ctx, svgData.vpMat);

            svgData.shapes.forEach(shape => {
                ctx.save();
                // オブジェクト変換行列をかける
                Matrix.transform(ctx, shape.mat);

                // 描画するpathを取得する
                const path = svgData.paths.find(p => p.c === shape.c);
                if(!path) { return; } // continue;
                
                if(options.fillChar) {// 文字を塗る
                    ctx.fillStyle = options.fillStyle ? options.fillStyle : 'green';
                    ctx.lineWidth = 10;
                    ctx.beginPath();
                    path.curvesArray.forEach(curves => {
                        curves.forEach((curve, i) => { 
                            curve.path(ctx, i === 0); 
                        });
                    });
                    ctx.closePath();
                    ctx.fill();
                }       
                
                if(options.strokeRect) {
                    const rect = path.rect;
                    ctx.strokeStyle = 'red';
                    ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                }               

                ctx.restore();                 
            });

            ctx.restore();
        }
        
        function drawData(ctx, data) {
            ctx.save();

            Matrix.setTransform(ctx, data.mat);

            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 6;
            data.kvg.paths.forEach(path => {
                
                ctx.beginPath();

                path.curvesArray.forEach((curves, i) => {
                    curves.forEach((curve, j) => { 
                        curve.path(ctx, j === 0); 
                    });
                });            

                ctx.stroke();
            });

            ctx.restore();
        }
        function getDatas(svgData, kvgData) {
            const ret = [];

            // ret に kvgDataのインデックスと変換行列を格納していく
            svgData.shapes.forEach(shape => {

                // 描画するpathを取得する
                const path = svgData.paths.find(p => p.c === shape.c);
                if(!path) { return; } // continue;       

                // MathJax のshape.rectをスクリーン座標系へ変換する
                const mat = Matrix.multiply(svgData.vpMat, shape.mat);                
                const screenRect = Matrix.multiplyRect(mat, path.rect); // スクリーン座標系の矩形

                // shape に対応する kvg 用のコードを取得する
                if(shape.tagName !== 'use') {
                    return;
                }
                const id = shape.xlinkHref.substring(1);
                let kvgCode = SvgParser.toKanjiVGCodeById(id);
                kvgCode = Utility.zeroPadding(kvgCode, Define.SVG_FILE_NAME_LENGTH);

                // get kvg paths
                const data = kvgData.find(data => data.c === kvgCode); 
                if(!data) { 
                    console.log('kvg paths are not found.');
                    return;
                }

                // path の矩形を事前に計算しておく
                const kvgRect = data.rect;
                const newKvgRect = Utility.fitVerticalRect(screenRect, kvgRect);

                // 変換行列を求める
                const trans = Matrix.translate(-newKvgRect.x, -newKvgRect.y);
                const scale = Matrix.scale(screenRect.width / newKvgRect.width, screenRect.height / newKvgRect.height);
                const revTrans = Matrix.translate(screenRect.x, screenRect.y);

                let newMat = Matrix.multiply(scale, trans);
                newMat = Matrix.multiply(revTrans, newMat);

                ret.push({ kvg: data, mat: newMat, });
            });

            return ret;
        }
    }
});
</script>
<style>
#textarea {
	width: 600px;
	height: 200px;
    font-size: 18px;
}
#canvas {
  border: 1px solid #eeeeee;
}
</style>
</head>
<body>
	<textarea id="textarea">\huge{\begin{eqnarray}
1234
\end{eqnarray}}</textarea><br>
	<input id="display-checkbox" type="checkbox" checked="true"/><label for="display-checkbox">display</label>    
    <button id="button">tex2svg</button>
    &nbsp;&nbsp;
    <a href="input-tex2svg.html">sample page</a><br><br>
    <a href="char-def.html">char def</a><br><br>
	<canvas id="canvas" width="600" height="300"></canvas>
</body>
</html>
