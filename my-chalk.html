<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>chalkboard</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="js/matrix.js"></script>
<script>
$(document).ready(main);
function main() {
    const zoomRate = 6;
    const canvas = $('#my-canvas')[0];
    canvas.width = 200;
    canvas.height = 40;
    $('#my-canvas').css({ 
        width: `${ canvas.width * zoomRate }px`, 
        height: `${ canvas.height * zoomRate }px`, 
        imageRendering: 'pixelated' 
    });
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.strokeStyle = 'white';
    ctx.lineCap = 'round';
    ctx.lineWidth = 20;
    ctx.beginPath();
    ctx.moveTo(20, 20);
    ctx.lineTo(180, 20);
    ctx.stroke();
    const imageData = pixelData(ctx);
    ctx.putImageData(imageData, 0, 0);
    
    const debugCanvas = $('#debug-canvas')[0];
    debugCanvas.width = 40;
    debugCanvas.height = 40;
    $('#debug-canvas').css({ 
        width: `${ debugCanvas.width * zoomRate }px`, 
        height: `${ debugCanvas.height * zoomRate }px`, 
        imageRendering: 'pixelated' 
    });
    getArray({ x: 10, y: 10, }, Math.PI * 3 / 6, { x: 20, y: 20, });
}
function pixelData(ctx) {
    const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    const data = imageData.data;
    const boundaryArray = [];
    const innerArray = [];
    for(let i = 0; i < data.length / 4; i += 1) {
        let x = i % ctx.canvas.width;
        let y = Math.floor(i / ctx.canvas.width);
        if(isPointBackground(imageData, x, y)) {
            continue;
        }

        // 外周を得る

        // 上下左右いづれかが(0,0,0,255)ならその点は外周
        const rand = Math.random();
        const boundary = isPointBoundary(imageData, x, y);

        if(boundary) {
            boundaryArray.push({ x, y, });
        } else {
            innerArray.push({ x, y, });
        }
    }

    // 外周を塗る
    fillArray(boundaryArray, 0.1, { r: 255, g: 0, b: 0, a: 255, });

    // 内側を塗る
    fillArray(innerArray, 0.015, { r: 0, g: 0, b: 0, a: 255, });

    return imageData;

    function fillArray(array, value, color) {
        array.forEach(elm => {
            const rand = Math.random();
            if(rand >= value) { return; }
            const i = elm.y * imageData.width + elm.x;
            data[i * 4 + 0] = color.r;
            data[i * 4 + 1] = color.g;
            data[i * 4 + 2] = color.b;
            data[i * 4 + 3] = color.a;
        });
    }

    function isPointBackground(imageData, x, y) {
        if(x < 0 || x >= imageData.width) { return false; }
        if(y < 0 || y >= imageData.height) { return false; }
        const data = imageData.data;
        const i = y * imageData.width + x;
        const r = data[i * 4 + 0];
        const g = data[i * 4 + 1];
        const b = data[i * 4 + 2];
        const a = data[i * 4 + 3];
        if(r === 0 && g === 0 && b === 0 && a === 255) {
            return true;
        } else {
            return false;
        }
    }

    function isPointBoundary(imageData, x, y) {
        if(x < 0 || x >= imageData.width) { return false; }
        if(y < 0 || y >= imageData.height) { return false; }
        if(isPointBackground(imageData, x + 1, y)
        || isPointBackground(imageData, x, y + 1)
        || isPointBackground(imageData, x - 1, y)
        || isPointBackground(imageData, x, y - 1)) {
            return true;
        } else {
            return false;
        }
    }
}
/**
 * @param {number} m 拡大率
 * https://qiita.com/c60evaporator/items/d53053358105b0117f2c
 * 
 **/
function getArray(scale, theta, mu) {
    const scaleMat = Matrix.scale(scale.x, scale.y);
    const rotMat = Matrix.rotate(theta);
    const transMat = Matrix.translate(mu.x, mu.y);
    const sigma = Matrix.multiply(rotMat, scaleMat);
    const mat = Matrix.multiply(transMat, sigma);

    const debugCanvas = document.querySelector('#debug-canvas');
    const debugCtx = debugCanvas.getContext('2d');
    debugCtx.fillStyle = 'gray';
    debugCtx.fillRect(0, 0, debugCtx.canvas.width, debugCtx.canvas.height);

    // 点を発生させる
    debugCtx.fillStyle = 'red';
    debugCtx.strokeStyle = 'red';
    debugCtx.beginPath();
    for(let i = 0; i < 24; i += 1) {
        const theta = Math.PI * 2 * i / 24;
        const x = Math.cos(theta);
        const y = Math.sin(theta);
        const nPos = Matrix.multiplyVec(mat, { x, y, });
        if(i === 0) {
            debugCtx.moveTo(nPos.x, nPos.y);
        } else {
            debugCtx.lineTo(nPos.x, nPos.y);
        }
    }
    debugCtx.closePath();
    debugCtx.stroke();
    //return;

    const imageData = debugCtx.getImageData(0, 0, debugCtx.canvas.width, debugCtx.canvas.height);
    const data = imageData.data;

    // (0,0) を変換した点のpdfを計算する
    let nPos = Matrix.multiplyVec(mat, { x: 0, y: 0 });
    const pdf0Sigma = getPdf(nPos, sigma, mu);
    console.log(nPos, pdf0Sigma);
    // (1,0) を変換した点のpdfを計算する
    nPos = Matrix.multiplyVec(mat, { x: 1, y: 0 });
    const pdf1Sigma = getPdf(nPos, sigma, mu);
    console.log(nPos, pdf1Sigma);
    // (2,0) を変換した点のpdfを計算する
    nPos = Matrix.multiplyVec(mat, { x: 2, y: 0 });
    const pdf2Sigma = getPdf(nPos, sigma, mu);
    console.log(nPos, pdf2Sigma);

    return;

    for(let i = 0; i < data.length / 4; i += 1) {
        const x = i % debugCtx.canvas.width;
        const y = Math.floor(i / debugCtx.canvas.width);
        //const ret = isPosInRect(x, y, rect);
        //if(ret) {                    
            const pdf = getPdf({x, y}, sigma, mu);
            const rand = Math.random();

            if(rand <= pdf) {//pdf > pdf2Sigma * 0.99) {
                data[i * 4 + 0] = 255;
                data[i * 4 + 1] = 0;
                data[i * 4 + 2] = 0;
                data[i * 4 + 3] = 255;
            }      
        //}
    }
    debugCtx.putImageData(imageData, 0, 0);

    function getPdf(p, sigma, mu) {
        const v = { x: p.x - mu.x, y: p.y - mu.y, };
        const invMat = Matrix.inverse(sigma);
        const nv = Matrix.multiplyVec(invMat, v);
        const pdf = Math.exp(-1 / 2 * (v.x * nv.x + v.y * nv.y));
        return pdf;
    }
}

function isPosInRect(x, y, rect) {
    if(rect.x <= x && x <= rect.x + rect.width
    && rect.y <= y && y <= rect.y + rect.height) {
        return true;
    } else {
        return false;
    }
}

</script>
</head>
<body>
    <canvas id="my-canvas"></canvas>
    <canvas id="debug-canvas" width="400" height="400"></canvas>
</body>
</html>
