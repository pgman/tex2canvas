<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>chalkboard</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="js/matrix.js"></script>
<script src="js/min-max.js"></script>
<script src="js/vector.js"></script>
<script src="js/utility.js"></script>
<script>
/*
TODO
共分散 sigmaXYが効いていないような気がする
点を消すときに乱数を複数回発生させて、それを透明度とするのはどうだろうか(10回中7回成功なら 255 * 7 / 10とする)
線を細くするロジックを入れても面白いかもしれない
結構メモリを食ってしまうので、描画するものだけ表示するロジックがよいかもしれない
*/

/*
Canvas2D: Multiple readback operations using getImageData are faster 
with the willReadFrequently attribute set to true. 
See: https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently


createCanvas	@	VM648 my-chalk.html:305
getPixelData	@	VM648 my-chalk.html:237
updateCanvas	@	VM648 my-chalk.html:27
main	@	VM648 my-chalk.html:19
*/
$(main);
let lineWidth = 8,
    boundaryThreshold = 0.1,
    externalThreshold = 0.05,
    sigmaX = 2,
    sigmaY = 2,
    sigmaXY = 0, 
    length = 5;
function main() {
    updateView();
    updateCanvas();
    document.querySelector('#update-button').addEventListener('click', e => {
        updateModel();
        updateCanvas();
    }, false);
}

function updateCanvas() {
    const pixelData = getPixelData(
        [
            { x: 20, y: 20, }, 
            { x: 180, y: 20, },
            { x: 100, y: 100, },
            { x: 40, y: 60, },
            { x: 80, y: 20, },
        ], 
        lineWidth, 
        { r: 255, g: 255, b: 255, a: 1 },   // a は 0.0 ～ 1.0を指定
        boundaryThreshold, externalThreshold,
        sigmaX, sigmaY, sigmaXY, length
    );

    console.log(pixelData.memory + ' bytes');

    let count = 0;
    setInterval(() => {
        const zoomRate = 1;
        const canvas = $('#canvas')[0];
        canvas.width = pixelData.imageData.width;
        canvas.height = pixelData.imageData.height;
        $('#canvas').css({ 
            width: `${ canvas.width * zoomRate }px`, 
            height: `${ canvas.height * zoomRate }px`, 
            imageRendering: 'pixelated' 
        });

        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.drawImage(pixelData.canvasArray[count], 0, 0);
        count += 1;
        if(count >= pixelData.canvasArray.length) {
            count = 0;
        }  
    }, 1000 / 60);

    // const zoomRate = 1;
    // const canvas = $('#canvas')[0];
    // canvas.width = pixelData.imageData.width;
    // canvas.height = pixelData.imageData.height;
    // $('#canvas').css({ 
    //     width: `${ canvas.width * zoomRate }px`, 
    //     height: `${ canvas.height * zoomRate }px`, 
    //     imageRendering: 'pixelated' 
    // });

    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.drawImage(pixelData.canvas, 0, 0);  
}

function updateView() {
    document.querySelector('#line-width-text').value = lineWidth + '';
    document.querySelector('#boundary-threshold-text').value = boundaryThreshold + '';
    document.querySelector('#external-threshold-text').value = externalThreshold + '';
    document.querySelector('#sigma-x-text').value = sigmaX + '';
    document.querySelector('#sigma-y-text').value = sigmaY + '';
    document.querySelector('#sigma-xy-text').value = sigmaXY + '';
}

function updateModel() {
    const tempLineWidth = Number(document.querySelector('#line-width-text').value);
    const tempBoundaryThreshold = Number(document.querySelector('#boundary-threshold-text').value);
    const tempExternalThreshold = Number(document.querySelector('#external-threshold-text').value);
    const tempSigmaX = Number(document.querySelector('#sigma-x-text').value);
    const tempSigmaY = Number(document.querySelector('#sigma-y-text').value);
    const tempSigmaXY = Number(document.querySelector('#sigma-xy-text').value);
    if(isNaN(tempLineWidth) || isNaN(tempBoundaryThreshold) || isNaN(tempExternalThreshold)
    || isNaN(tempSigmaX) || isNaN(tempSigmaY) || isNaN(tempSigmaXY)) {
        alert('invalid input.')
        return;
    }
    lineWidth = tempLineWidth;
    boundaryThreshold = tempBoundaryThreshold;
    externalThreshold = tempExternalThreshold;
    sigmaX = tempSigmaX;
    sigmaY = tempSigmaY;
    sigmaXY = tempSigmaXY;
}

function getPixelData(posArray, lineWidth, strokeStyle, boundaryThreshold, internalThreshold, 
                    sigmaX, sigmaY, sigmaXY, length) {
    // posArrayのmin/maxを取得する
    MinMax.init();
    posArray.forEach(pos => { MinMax.add(pos); });
    const mm = MinMax.get();
    // minを切り捨てる maxを切り上げる
    mm.minX = Math.floor(mm.minX);
    mm.minY = Math.floor(mm.minY);
    mm.maxX = Math.floor(mm.maxX);
    mm.maxY = Math.floor(mm.maxY);

    const padding = 2;
    const radius = Math.round(lineWidth / 2);
    mm.minX -= radius + padding;
    mm.minY -= radius + padding;
    mm.maxX += radius + padding;
    mm.maxY += radius + padding;

    // canvasを作成し、そこに描画する
    const width = mm.maxX - mm.minX;
    const height = mm.maxY - mm.minY;

    const canvas = Utility.createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = `rgba(${strokeStyle.r},${strokeStyle.g},${strokeStyle.b},${strokeStyle.a})`; // a は 0.0～1.0
    ctx.setTransform(1, 0, 0, 1, -mm.minX, -mm.minY);    
    posArray.forEach((pos, i) => { 
        if(i > 0) {
            const posPre = posArray[i - 1];
            ctx.beginPath();
            ctx.moveTo(posPre.x, posPre.y);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        } 
    });    
    ctx.restore();

    // ピクセルの外側と内側に分けて除去するピクセルを選択する
    const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    const data = imageData.data;
    let boundaryArray = []; // 境界の点の配列
    let internalArray = []; // 内部の点の配列

    for(let i = 0; i < data.length / 4; i += 1) {
        const x = i % ctx.canvas.width;
        const y = Math.floor(i / ctx.canvas.width);

        if(isPointExternal(imageData, x, y)) {// 外部
            continue;
        }
        // 境界かどうか判定
        const boundary = isPointBoundary(imageData, x, y);
        if(boundary) {// 境界
            boundaryArray.push({ x, y, });
        } else {// 内部
            internalArray.push({ x, y, });
        }
    }

    // 境界の点に乱数によるフィルターをかける
    boundaryArray = boundaryArray.filter(() => Math.random() < boundaryThreshold);

    // 内部の点に乱数によるフィルターをかける
    internalArray = internalArray.filter(() => Math.random() < internalThreshold);

    let occurArray = [];

    // 境界の点から生起する点を取得する
    boundaryArray.forEach(p => {
        const posArray = getPosArray(sigmaX, sigmaY, sigmaXY, p);
        occurArray = occurArray.concat(posArray);
    });
    
    // 内部の点から生起する点を取得する
    internalArray.forEach(p => {
        const posArray = getPosArray(sigmaX, sigmaY, sigmaXY, p);
        occurArray = occurArray.concat(posArray);
    });

    occurArray = occurArray.concat(boundaryArray);
    occurArray = occurArray.concat(internalArray);

    // 除去する点を非表示にする
    occurArray.forEach(p => {
        const x = p.x;
        const y = p.y;
        if(x < 0 || x >= imageData.width) { return; }
        if(y < 0 || y >= imageData.height) { return; }
        const i = y * imageData.width + x;

        data[i * 4 + 0] = 0;
        data[i * 4 + 1] = 0;
        data[i * 4 + 2] = 0;
        data[i * 4 + 3] = 0;
    });

    ctx.putImageData(imageData, 0, 0);

    // アニメーション用のcanvasを作成する
    const canvasArray = [];

    // 全体の長さを求めてみる
    const wholeLength = posArray.reduce((p, c, i) => p + (i > 0 ? Vector.dist(posArray[i - 1], c) : 0), 0);    
    console.log('whole length: ', wholeLength);

    let curLength = 0;
    let dbgCnt = 0;
    while(true) {
        if(dbgCnt++ > 1000) { 
            console.error('inifinity loop!!');
            break;
        }
        const targetLength = curLength + length;    // これを超えないようにする
        let tmpLength = 0;
        let tmpIndex = -1;
        for(let i = 0; i < posArray.length; i += 1) {
            if(i - 1 < 0) { continue; } // i === 1 からループする
            const dist = Vector.dist(posArray[i - 1], posArray[i]);
            tmpLength += dist;
            if(curLength <= tmpLength) {      
                tmpIndex = i;
                const diff = curLength - tmpLength + dist;
                const frameCanvas = createCanvas(canvas, posArray, tmpIndex, diff / dist);
                canvasArray.push(frameCanvas);
                break;
            } else if(i + 1 >= posArray.length) {
                // 最終
                tmpIndex = posArray.length - 1;
                const frameCanvas = createCanvas(canvas, posArray, tmpIndex, 1);
                canvasArray.push(frameCanvas);
            }
        }
        const epsilon = 0.00001;
        if(curLength >= wholeLength - epsilon) {
            break;
        }        
        curLength += length;
    }

    return {
        translate: {
            x: mm.minX,
            y: mm.minY,
        },
        canvas,
        imageData,
        boundaryArray,
        internalArray,
        canvasArray,
        memory: canvasArray.length * canvas.width * canvas.height * 4,
    };

    function createCanvas(srcCanvas, posArray, index, rate) {
        const tmpCanvas = Utility.createCanvas(srcCanvas.width, srcCanvas.height);
        const tmpCtx = tmpCanvas.getContext('2d');
        // 描画する(何色でもよいので、白色で塗る)
        tmpCtx.save();
        tmpCtx.lineCap = 'round';
        tmpCtx.lineWidth = lineWidth;
        tmpCtx.strokeStyle = `rgba(255, 255, 255, 1)`; // a は 0.0～1.0
        tmpCtx.setTransform(1, 0, 0, 1, -mm.minX, -mm.minY);    
        posArray.forEach((pos, i) => { 
            if(i <= 0 || i > index) { return; }
            const posPre = posArray[i - 1];
            let newPos;
            if(i < index) {     
                newPos = pos;
            } else if(i === index) {
                let vec = Vector.subtract(pos, posPre);
                vec = Vector.scale(vec, rate);
                newPos = Vector.add(posPre, vec);
            }
            tmpCtx.beginPath();
            tmpCtx.moveTo(posPre.x, posPre.y);
            tmpCtx.lineTo(newPos.x, newPos.y);
            tmpCtx.stroke();
        });
        tmpCtx.restore();

        // 塗られている箇所のみを塗る
        const tmpImageData = tmpCtx.getImageData(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
        const tmpData = tmpImageData.data;

        // 返すcanvas
        const retCanvas = Utility.createCanvas(srcCanvas.width, srcCanvas.height);
        const retCtx = retCanvas.getContext('2d');
        const retImageData = retCtx.getImageData(0, 0, retCtx.canvas.width, retCtx.canvas.height);
        const retData = retImageData.data;

        const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });
        const srcImageData = srcCtx.getImageData(0, 0, srcCtx.canvas.width, srcCtx.canvas.height);
        const srcData = srcImageData.data;
        
        let filledCount = 0;
        for(let i = 0; i < tmpData.length / 4; i += 1) {
            const x = i % tmpCtx.canvas.width;
            const y = Math.floor(i / tmpCtx.canvas.width);

            if(isPointExternal(tmpImageData, x, y)) {// 外部
                continue;
            }
            // debug用に塗られている箇所の数をカウントしてみる
            filledCount++;
            for(j = 0; j < 4; j += 1) {
                retData[i * 4 + j] = srcData[i * 4 + j];
            }            
        }
        console.log('filledCount: ' + filledCount);
        retCtx.putImageData(retImageData, 0, 0);
        
        return retCanvas;
    }

    function oneTo255(value) {
        if(value === 1) { return 255; }
        return Math.round(value * 255);
    }

    /**
     * 点が外部か判定する
     */
    function isPointExternal(imageData, x, y) {
        if(x < 0 || x >= imageData.width) { return false; }
        if(y < 0 || y >= imageData.height) { return false; }
        const data = imageData.data;
        const i = y * imageData.width + x;
        const r = data[i * 4 + 0];
        const g = data[i * 4 + 1];
        const b = data[i * 4 + 2];
        const a = data[i * 4 + 3];
        if(r === 0 && g === 0 && b === 0 && a === 0) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * 点が境界か判定する
     */
    function isPointBoundary(imageData, x, y) {
        if(x < 0 || x >= imageData.width) { return false; }
        if(y < 0 || y >= imageData.height) { return false; }
        if(isPointExternal(imageData, x + 1, y)
        || isPointExternal(imageData, x, y + 1)
        || isPointExternal(imageData, x - 1, y)
        || isPointExternal(imageData, x, y - 1)) {
            return true;
        } else {
            return false;
        }
    }
}
/**
 * https://qiita.com/c60evaporator/items/d53053358105b0117f2c
 * 
 **/
function getPosArray(sigmaX, sigmaY, sigmaXY, mu) {
    const sigmaX2 = sigmaX * sigmaX;
    const sigmaY2 = sigmaY * sigmaY;
    const sigma = [ sigmaX2, sigmaXY,   0, 
                    sigmaXY, sigmaY2,   0, 
                          0,       0,   1];
    const transMat = Matrix.translate(mu.x, mu.y);
    const mat = Matrix.multiply(transMat, sigma);

    const posArray = [];
    const roundSigmaX = Math.round(sigmaX);
    const roundSigmaY = Math.round(sigmaY);
    for(let x = mu.x - 2 * roundSigmaX; x <= mu.x + 2 * roundSigmaX; x += 1) {
        for(let y = mu.y - 2 * roundSigmaY; y <= mu.y + 2 * roundSigmaY; y += 1) {
            const pdf = getPdf({x, y}, sigma, mu);
            const rand = Math.random();
            if(rand <= pdf) {
                posArray.push({x, y});
            }
        }
    }
    return posArray;
}

/**
 * pdf(確率密度関数)の値を求める
 * @param {number} p 位置ベクトル
 * @param {number} sigma 分散共分散行列
 * @param {number} mu 平均
 * @returns {void} なし
 */
function getPdf(p, sigma, mu) {
    const v = { x: p.x - mu.x, y: p.y - mu.y, };
    const invMat = Matrix.inverse(sigma);
    const nv = Matrix.multiplyVec(invMat, v);
    const pdf = Math.exp(-1 / 2 * (v.x * nv.x + v.y * nv.y)); // あえて正規化しない。そうすると平均の点のpdfがちょうど1になるので都合がよい
    return pdf;
}

</script>
<style>
.input-text {
    width: 60px;
}
</style>
</head>
<body>
    <div style="margin: 8px;">
        line width:&nbsp;<input id="line-width-text" class="input-text" type="text"><br>
        boundary threshold:&nbsp;<input id="boundary-threshold-text" class="input-text" type="text"><br>
        external threshold:&nbsp;<input id="external-threshold-text" class="input-text" type="text"><br>
        sigma x:&nbsp;<input id="sigma-x-text" class="input-text" type="text"><br>
        sigma y:&nbsp;<input id="sigma-y-text" class="input-text" type="text"><br>
        sigma xy:&nbsp;<input id="sigma-xy-text" class="input-text" type="text"><br>
        <input id="update-button" type="button" value="update">
    </div>
    <canvas id="canvas"></canvas><br>
</body>
</html>
