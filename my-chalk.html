<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>chalkboard</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="js/matrix.js"></script>
<script>
$(document).ready(main);
function main() {
    const zoomRate = 6;
    const canvas = $('#my-canvas')[0];
    canvas.width = 200;
    canvas.height = 40;
    $('#my-canvas').css({ 
        width: `${ canvas.width * zoomRate }px`, 
        height: `${ canvas.height * zoomRate }px`, 
        imageRendering: 'pixelated' 
    });
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.strokeStyle = 'white';
    ctx.lineCap = 'round';
    ctx.lineWidth = 20;
    ctx.beginPath();
    ctx.moveTo(20, 20);
    ctx.lineTo(180, 20);
    ctx.stroke();
    let imageData = pixelData(ctx);
    ctx.putImageData(imageData, 0, 0);
    
    const debugCanvas = $('#debug-canvas')[0];
    debugCanvas.width = 40;
    debugCanvas.height = 40;
    $('#debug-canvas').css({ 
        width: `${ debugCanvas.width * zoomRate }px`, 
        height: `${ debugCanvas.height * zoomRate }px`, 
        imageRendering: 'pixelated' 
    });

    const sigmaX = 1;
    const sigmaY = 1;
    const sigmaXY = 0;
    const sigmaX2 = sigmaX * sigmaX;
    const sigmaY2 = sigmaY * sigmaY;
    const mu = { x: 20, y: 20 };
    const sigma = [ sigmaX2, sigmaXY,   0, 
                    sigmaXY, sigmaY2,   0, 
                          0,       0,   1];
    const posArray = getPosArray(sigmaX, sigmaY, sigmaXY, mu);

    const debugCtx = debugCanvas.getContext('2d');
    debugCtx.fillStyle = 'gray';
    debugCtx.fillRect(0, 0, debugCtx.canvas.width, debugCtx.canvas.height);

    imageData = debugCtx.getImageData(0, 0, debugCtx.canvas.width, debugCtx.canvas.height);
    const data = imageData.data;
    posArray.forEach(p => {
        const x = p.x;
        const y = p.y;
        const i = y * debugCtx.canvas.width + x;
        const pdf = getPdf({x, y}, sigma, mu);
        const rand = Math.random();
        if(rand <= pdf) {
            data[i * 4 + 0] = 255;
            data[i * 4 + 1] = 0;
            data[i * 4 + 2] = 0;
            data[i * 4 + 3] = 255;
        }  
    });
    debugCtx.putImageData(imageData, 0, 0);
}
// このメソッドが完成すれば
function getPixelData(posArray, lineWidth, fillStyle) {
    // posArrayのmin/maxを取得する
}
function pixelData(ctx) {
    const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    const data = imageData.data;
    const boundaryArray = [];
    const innerArray = [];
    for(let i = 0; i < data.length / 4; i += 1) {
        let x = i % ctx.canvas.width;
        let y = Math.floor(i / ctx.canvas.width);
        if(isPointBackground(imageData, x, y)) {
            continue;
        }
        const rand = Math.random();
        const boundary = isPointBoundary(imageData, x, y);

        if(boundary) {
            boundaryArray.push({ x, y, });
        } else {
            innerArray.push({ x, y, });
        }
    }

    // 外周を塗る
    fillArray(boundaryArray, 0.1, { r: 255, g: 0, b: 0, a: 255, });

    // 内側を塗る
    fillArray(innerArray, 0.015, { r: 0, g: 0, b: 0, a: 255, });

    return imageData;

    function fillArray(array, value, color) {
        array.forEach(elm => {
            const rand = Math.random();
            if(rand >= value) { return; }
            const i = elm.y * imageData.width + elm.x;
            data[i * 4 + 0] = color.r;
            data[i * 4 + 1] = color.g;
            data[i * 4 + 2] = color.b;
            data[i * 4 + 3] = color.a;
        });
    }

    function isPointBackground(imageData, x, y) {
        if(x < 0 || x >= imageData.width) { return false; }
        if(y < 0 || y >= imageData.height) { return false; }
        const data = imageData.data;
        const i = y * imageData.width + x;
        const r = data[i * 4 + 0];
        const g = data[i * 4 + 1];
        const b = data[i * 4 + 2];
        const a = data[i * 4 + 3];
        if(r === 0 && g === 0 && b === 0 && a === 255) {
            return true;
        } else {
            return false;
        }
    }

    function isPointBoundary(imageData, x, y) {
        if(x < 0 || x >= imageData.width) { return false; }
        if(y < 0 || y >= imageData.height) { return false; }
        if(isPointBackground(imageData, x + 1, y)
        || isPointBackground(imageData, x, y + 1)
        || isPointBackground(imageData, x - 1, y)
        || isPointBackground(imageData, x, y - 1)) {
            return true;
        } else {
            return false;
        }
    }
}
/**
 * https://qiita.com/c60evaporator/items/d53053358105b0117f2c
 * 
 **/
function getPosArray(sigmaX, sigmaY, sigmaXY, mu) {
    const sigmaX2 = sigmaX * sigmaX;
    const sigmaY2 = sigmaY * sigmaY;
    const sigma = [ sigmaX2, sigmaXY,   0, 
                    sigmaXY, sigmaY2,   0, 
                          0,       0,   1];
    const transMat = Matrix.translate(mu.x, mu.y);
    const mat = Matrix.multiply(transMat, sigma);

    const posArray = [];
    const roundSigmaX = Math.round(sigmaX);
    const roundSigmaY = Math.round(sigmaY);
    for(let x = mu.x - 2 * roundSigmaX; x <= mu.x + 2 * roundSigmaX; x += 1) {
        for(let y = mu.y - 2 * roundSigmaY; y <= mu.y + 2 * roundSigmaY; y += 1) {
            const pdf = getPdf({x, y}, sigma, mu);
            const rand = Math.random();
            if(rand <= pdf) {
                posArray.push({x, y});
            }
        }
    }
    return posArray;
}
function getPdf(p, sigma, mu) {
    const v = { x: p.x - mu.x, y: p.y - mu.y, };
    const invMat = Matrix.inverse(sigma);
    const nv = Matrix.multiplyVec(invMat, v);
    const pdf = Math.exp(-1 / 2 * (v.x * nv.x + v.y * nv.y));
    return pdf;
}

</script>
</head>
<body>
    <canvas id="my-canvas"></canvas>
    <canvas id="debug-canvas" width="400" height="400"></canvas>
</body>
</html>
