<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script src="js/define.js"></script>
<script src="js/svg-parser.js"></script>
<script src="js/kanjivg.js"></script>
<script src="js/curve.js"></script>
<script src="js/path.js"></script>
<script src="js/stroke.js"></script>
<script src="js/figure.js"></script>
<script src="js/vector.js"></script>
<script src="js/min-max.js"></script>
<script src="js/utility.js"></script>
<script src="js/cubic-bezier-curve.js"></script>
<script src="js/paint.js"></script>
<script src="js/scalar.js"></script>
<script src="js/matrix.js"></script>
<script src="js/graphics.js"></script>
<script src="js/graphics-api.js"></script>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.2.0/chart.min.js"
  integrity="sha512-VMsZqo0ar06BMtg0tPsdgRADvl0kDHpTbugCBBrL55KmucH6hP9zWdLIWY//OTfMnzz6xWQRxQqsUFefwHuHyg=="
  crossorigin="anonymous"></script>
<script
  src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@next/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<title>bezier image</title>
<script>
document.addEventListener('DOMContentLoaded', async () => {

    // create model
    const points0 = [
        { x: 100, y: 400, },
        { x: 200, y: 100, },
        { x: 300, y: 100, },
        { x: 400, y: 400, },
    ];
    const points1 = [
        { x: 400, y: 400, },
        { x: 500, y: 700, },
        { x: 600, y: 700, },
        { x: 700, y: 400, },
    ];
    const points2 = [
        { x: 700, y: 400, },
        { x: 200, y: 400, },
    ];

    const lineWidth = 5;
    const step = 1;

    const img = await Utility.loadImage('chalk-lines/chalk-frame-8(1460-664-1809-1215).png'); 
    //const img = await Utility.loadImage('images/america.png');
    //const img = await Utility.loadImage('images/yellow.png');
    const imageData  = GraphicsApi.getImageDataByImage(img);
    const path = new Path([ new Curve(points0), new Curve(points1), new Curve(points2) ]);
    const stroke = new Stroke([ path ]);
    let figure = new Figure([ stroke ]);
    figure.splitAtNonSmoothPoints();
    figure.stretch(lineWidth * .5);
    figure.strokes.forEach(stroke => {
        stroke.paths.forEach(path => {
            path.imageData = imageData;
        });
    });    

    const backCanvas = document.querySelector('#back-canvas');
    const backCtx = backCanvas.getContext('2d', { willReadFrequently: true });

    const backImg = await Utility.loadImage('images/black_board.jpg');
    backCtx.drawImage(backImg, 0, 0, backCtx.canvas.width, backCtx.canvas.height);

    let intervalId = -1;

    // #done-button click
    document.querySelector('#done-button').addEventListener('click', e => {
        const canvas = document.querySelector('#my-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const size = { width: ctx.canvas.width, height: ctx.canvas.height, };        

        // clear interval
        if(intervalId >= 0) { clearInterval(intervalId); }
        
        // update segments
        const startTime = new Date();
        ctx.reset();
        let segments = [];
        figure.strokes.forEach(stroke => {
            stroke.paths.forEach(path => {
                path.updateSegments(size, lineWidth, step);
                segments = segments.concat(path.segments);
            });
        });
        const endTime = new Date();

        const workCanvas = Utility.createCanvas(ctx.canvas.width, ctx.canvas.height);
        const workCtx = workCanvas.getContext('2d', { willReadFrequently: true });
        const workImageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
            
        let animCnt = 0;
        intervalId = setInterval(() => {
            ctx.reset();
            const pixels = segments[animCnt].pixels;
            pixels.forEach(elm => {
                if(elm.a) {
                    Graphics.setColorByIndex(workImageData, elm.i, [255, 255, 255, elm.a]);
                }                
            });
            untiAlias(workImageData, pixels, [255, 255, 255], 2, { start: 96, end: 16 });
            workCtx.putImageData(workImageData, 0, 0);
            ctx.drawImage(workCanvas, 0, 0);
            
            if(++animCnt >= segments.length) {
                clearInterval(intervalId);
            }
        }, 1 / 60);
        document.querySelector('#time-span').innerHTML = `${endTime - startTime} ms`;
    });

    function untiAlias(imageData, pixels, color, radius, alpha) {
        const data = imageData.data;
        const width = imageData.width;
        const height = imageData.height;
        const filtered = pixels.filter(elm => {
            const targetX = elm.i % width;
            const targetY = Math.floor(elm.i / width);
            const targetI = targetX + targetY * width;
            const targetA = data[targetI * 4 + 3];
            if(targetA < 128) {
                return;
            }
            // check filled around 8px
            const filledArray = [];
            let filled = false;
            for(let x = targetX - radius; x <= targetX + radius; x += 1) {
                for(let y = targetY - radius; y <= targetY + radius; y += 1) {
                    if(x < 0 || x >= width || y < 0 || y >= height || (x === targetX && y === targetY)) {
                        continue;
                    }
                    const adx = Math.abs(x - targetX);
                    const ady = Math.abs(y - targetY);
                    const i = x + y * width;
                    const a = data[i * 4 + 3];
                    filledArray.push(a !== 0);
                }
            }
            return filledArray.some(e => !e);
        });

        filtered.forEach(elm => {
            const targetX = elm.i % width;
            const targetY = Math.floor(elm.i / width);
            for(let x = targetX - radius; x <= targetX + radius; x += 1) {
                for(let y = targetY - radius; y <= targetY + radius; y += 1) {
                    if(x < 0 || x >= width || y < 0 || y >= height || (x === targetX && y === targetY)) {
                        continue;
                    }
                    const i = x + y * width;
                    const adx = Math.abs(x - targetX);
                    const ady = Math.abs(y - targetY);
                    let dist = Math.sqrt(adx ** 2 + ady ** 2) - 1;
                    if(dist < 0) { dist = 0; }
                    const maxDist = radius * Math.sqrt(2) - 1;
                    // get a 
                    const a = Scalar.linearInterpolation(alpha.start, alpha.end, dist / maxDist);
                    if(a > data[i * 4 + 3]) {                        
                        data[i * 4 + 0] = color[0];
                        data[i * 4 + 1] = color[1];
                        data[i * 4 + 2] = color[2];
                        data[i * 4 + 3] = a;
                    }   
                }
            }        
        });
    }

    // #insert-both-button
    document.querySelector('#insert-both-button').addEventListener('click', e => {
        figure.stretch(100);
        document.querySelector('#done-button').click();
    });

    // #transform-button
    document.querySelector('#transform-button').addEventListener('click', e => {        
        const m = Matrix.scale(1.2, 1.2);
        figure.transform(m);
        document.querySelector('#done-button').click();
    });

    // 05b97
    // #load-button
    document.querySelector('#load-button').addEventListener('click', async e => {        
        figure = await KanjiVG.loadFile('05b97');

        figure.strokes.forEach(stroke => {
            stroke.paths.forEach(path => {
                path.imageData = imageData;
            });
        }); 
    });

});

/*
[Figureに関する仕様]

figure は strokeの配列である: 'あ','山'のような文字1つに対応するものである
figure = [ stroke, stroke, ... , ];

stroke は path の配列である: 文字の1画に相当する
stroke = [ path, path, ... , ];

path は曲線群である: 滑らかに接続されたとみなした曲線群である。なので、1画が全て滑らかであれば、stroke は1つの path からなる
path = { curves: [curve, curve, ...], imageData: ..., segments: []};
path.curves: 曲線群
path.imageData: 曲線を描く画像のデータ(初期化後に格納する必要がある)
path.segments: 描画に必要な情報

curve は曲線である(現状3次ベジェ曲線のみ) 
curve = { type: 'cubic-bezier-curve', points: [ point, point, point, point ], length: 12.34222, rect: { x, y, width, height } }
curve.type: 曲線の種別(現状3次ベジェ曲線のみ)
curve.points: 曲線の制御点(大きさ4の配列)
curve.length: 曲線の長さ

point は点である(スクリーン座標系に変換しておく)
point = { x: 124.23983, y: 6.356, }

[使い方]
1: KVGやAVGから strokeArray を作成する
   path.curves, curve.type, curve.points, curve.length は格納しておく
   path.imageData === null, path.segments === [] としておく
2: dividePathメソッドを呼ぶ。
   strokeのpathが滑らかでない箇所で分割される -> 結果 stroke.length が大きくなる
     分割された path は stretchPath で lineWidth * 0.5 だけ引き延ばされる -> 結果 path.curves.length が大きくなり、path.length が大きくなる
3: 更新された strokeArray について、path.imageData を格納する
4: updateSegments メソッドにより、path 毎に segmentsを作成する
5: strokeArray の更新が完了したので、これをもとに描画する
*/
</script>
<style>
#back-canvas, #my-canvas {
    position: absolute;
    left: 8px;
    top: 60px;
}
</style>
</head>
<body>
    <button id="done-button">done</button>
    &nbsp;
    <button id="insert-both-button">insert both</button>
    <button id="transform-button">transform</button>
    <button id="load-button">load</button>
    &nbsp;
    <span id="time-span"></span>
    <canvas id="back-canvas" width="800" height="800"></canvas>
    <canvas id="my-canvas" width="800" height="800"></canvas>
</body>
</html>
