<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script src="js/vector.js"></script>
<script src="js/min-max.js"></script>
<script src="js/utility.js"></script>
<script src="js/cubic-bezier-curve.js"></script>
<script src="js/paint.js"></script>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.2.0/chart.min.js"
  integrity="sha512-VMsZqo0ar06BMtg0tPsdgRADvl0kDHpTbugCBBrL55KmucH6hP9zWdLIWY//OTfMnzz6xWQRxQqsUFefwHuHyg=="
  crossorigin="anonymous"></script>
<script
  src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@next/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<title>bezier image</title>
<script>
document.addEventListener('DOMContentLoaded', () => {

    // #done-button click
    document.querySelector('#done-button').addEventListener('click', e => {
        const canvas = document.querySelector('#my-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const points = [
            { x: 100, y: 400, },
            { x: 200, y: 100, },
            { x: 300, y: 100, },
            { x: 400, y: 400, },
        ];
        const startLineWidth = 20;
        const endLineWidth = 20;
        const img = new Image();
        img.onload = () => { 
            const startTime = new Date();
            const data = bezierImage(ctx, img, points, startLineWidth, endLineWidth, 0, 0.4); 
            const endTime = new Date();
            document.querySelector('#time-span').innerHTML = `${endTime - startTime} ms`;
            if(data) {
                //updateChart(data);
            }
            
        };
        img.src = 'chalk-images/chalk-line/chalk-line-2(26-1479-1290-336).png'; 
        //img.src = 'images/america.png';
        //img.src = 'images/yellow.png';
    });

    // #debug-button click
    document.querySelector('#debug-button').addEventListener('click', e => {
        const bezier0 = [
            { x: 50,  y: 200, },
            { x: 100, y: 100, },
            { x: 150, y: 100, },
            { x: 200, y: 200, },
        ];
        const bezier1 = [
            { x: 200, y: 200, },
            { x: 250, y: 300, },
            { x: 300, y: 300, },
            { x: 350, y: 200, },
        ];
        const bezier2 = [
            { x: 400, y: 100, },
            { x: 450, y: 100, },
            { x: 500, y: 100, },
            { x: 550, y: 100, },
        ];
        const path0 = [ bezier0, bezier1, bezier2 ];
        const path1 = [ bezier2 ];
        const stroke0 = [ path0, path1 ];
        const newStrokeArray = dividePath([ stroke0 ]);
        const lengthArray = getPathLength(newStrokeArray);
        // このlengthArray と同じ構造の画像を animationFrame 関数には渡すことになる

        // 色取得の startRate と endRate を実装する
        debugger;
    });
});

/**
 * strokeArray の path の長さを求める
 * @param {Array<stroke>} strokeArray ストロークの配列(1文字に相当)
 * @returns {Array<any>} strokeArrayと同じ構造でpathの代わりに長さが格納されているもの
 */
function getPathLength(strokeArray) {
    const newStrokeArray = [];
    for(let i = 0; i < strokeArray.length; i += 1) {
        const stroke = strokeArray[i];
        const newStroke = [];
        for(let j = 0; j < stroke.length; j += 1) {
            const path = stroke[j]; 
            let wholeLength = 0;           
            for(let k = 0; k < path.length; k += 1) {
                const bezier = path[k];
                const length = CubicBezierCurve.length(bezier, 1000);
                wholeLength += length;
            }
            newStroke.push(wholeLength);
        }
        newStrokeArray.push(newStroke);
    }
    return newStrokeArray;
}

/**
 * strokeArray の path を滑らかでない箇所で分割する
 * @param {Array<stroke>} strokeArray ストロークの配列(1文字に相当)
 * @returns {Array<stroke>} ストロークの配列
 */
function dividePath(strokeArray) {
    // まずはストロークを分割する必要があるか調べる
    // ストロークとは、1画に相当するもので、
    // なめらかなストロークなら1つのベジェ曲線群からなる
    // なめらかでないストロークは2つ以上のベジェ曲線群からなる
    // 滑らかに接続されたベジェ曲線群をsmoothedと表現する
    // ベジェ曲線はbezierと表現する
    // ベジェ曲線は3次ベジェ曲線であり、2次元ベジェ曲線は3次変換して扱う
    // よって、bezierは4点からなる配列とする
    // stroke = [ [b, b], [b], [b, b, b] ] = [ path, path, path ] 
    // path = [ b, b ]
    // bezier = b = [ p, p, p, p ] であり
    // point = p = { x, y } である

    const newStrokeArray = [];
    for(let i = 0; i < strokeArray.length; i += 1) {
        const stroke = strokeArray[i];
        const newStroke = [];
        for(let j = 0; j < stroke.length; j += 1) {
            const path = stroke[j];
            let curPath = [];
            for(let k = 0; k < path.length; k += 1) {
                curPath.push(path[k]);
                if(k === path.length - 1) { continue; } // last bezier curve
                const bezier = path[k];
                const bezierNext = path[k + 1];
                // two bezier curves are smoothed ? 
                const ret = CubicBezierCurve.isSmoothed(bezier, bezierNext);
                if(!ret) {// no smoothed -> cut path
                    newStroke.push(curPath);
                    curPath = [];
                }
            }
            newStroke.push(curPath);
        }
        newStrokeArray.push(newStroke);
    }
    return newStrokeArray;
}

/**
 * ベジェ曲線に沿って画像を描画する
 * @param {CanvasRenderingContext2D} ctx キャンバスのコンテキスト
 * @param {Image} img 画像
 * @param {Araay<{ x: number, y: number}>} 制御点の配列
 * @param {number} startLineWidth 始点の線の幅
 * @param {number} endLineWidth 終点の線の幅
 * @returns {void} なし
 */
function bezierImage(ctx, img, points, startLineWidth, endLineWidth, startXRate, endXRate) {
    const imageData = Utility.getImageDataByImage(img);

    // get whole length
    const wholeLength = CubicBezierCurve.length(points, 1000);
    
    ctx.reset();
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    const data = [];
    let curLength = 0;
    let preT = -1;
    let t = 0;
    while(true) {
        const pos = CubicBezierCurve.pointByT(points, t);
        if(preT >= 0) {
            const prePos = CubicBezierCurve.pointByT(points, preT);
            const dist = Vector.dist(pos, prePos);
            curLength += dist;
        }

        // tが微小変化(1/1000)したときの長さを求める
        const diffT = t + 1 / 1000;
        const diffPos = CubicBezierCurve.pointByT(points, diffT);
        const diff = Vector.dist(pos, diffPos);

        data.push({
            t,
            diff,
            length: curLength,
            first: Vector.length(CubicBezierCurve.firstDerivativeByT(points, t)),
            second: Vector.length(CubicBezierCurve.secondDerivativeByT(points, t)),
            curvature: CubicBezierCurve.curvatureByT(points, t),
        });

        // get first derivative
        let vector = CubicBezierCurve.firstDerivativeByT(points, t);
        // unit vectorize
        vector = Vector.unit(vector);
        // rotate -90 degree
        const nrm = Vector.nrm(vector);
        // nrm length
        const curLineWidth = startLineWidth + (endLineWidth - startLineWidth) * curLength / wholeLength;
        // get shifted point
        const top = Vector.add(pos, Vector.scale(nrm, curLineWidth / 2));
        const bottom = Vector.add(pos, Vector.scale(nrm, -curLineWidth / 2));
        const xRate = curLength / wholeLength;
        
        ctx.save();    
        const yDiv = Math.round(curLineWidth * 4);
        for(let j = 0; j <= yDiv; j += 1) {
            const yRate = j / yDiv;
            const internal = Utility.linearInterpolation(top, bottom, yRate); 
            // get internal point color            
            const color = Utility.getImageColor(imageData, xRate, yRate, startXRate, endXRate);
            // 本当は画素を直接描画したいがそうすると、きれいにはならない。
            ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a / 255})`;
            ctx.fillRect(internal.x, internal.y, 0.5, 0.5);
        }
        ctx.restore();

        // finish ?
        if(t === 1) { break; }
        // update t
        preT = t;
        let radius = 1/ Math.abs(CubicBezierCurve.curvatureByT(points, t));
        if(radius > 1) { radius = 1; }
        t += radius * 0.25 / diff / 1000;
        if(t > 1) { t = 1; }
    }
    return data;
}

function updateChart(data) {
    const ctx = document.getElementById('my-chart').getContext('2d');

    const myChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: data.map(d => d.length.toFixed(2)),
            datasets: [
                {
                    label: 'first',
                    data: data.map(d => d.first),
                    borderColor: '#f88',
                }, 
                {
                    label: 'diff',
                    data: data.map(d => d.diff),
                    borderColor: '#8f8',
                }, 
                {
                    label: 'second',
                    data: data.map(d => d.second),
                    borderColor: '#484',
                }, 
                {
                    label: 'curvature',
                    data: data.map(d => 1 / Math.abs(d.curvature)),
                    borderColor: '#48f',
                }
            ],
        },
    });
}
</script>
</head>
<body>
    <button id="done-button">done</button>
    &nbsp;
    <button id="debug-button">debug</button>
    &nbsp;
    <span id="time-span"></span>
    <br>
    <canvas id="my-canvas" width="600" height="500"></canvas>
    <br>
    <canvas id="my-chart"></canvas>
    <br><br>
</body>
</html>
